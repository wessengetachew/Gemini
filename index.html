
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Reduction Projection Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: #0a0e27;
            color: #e8e8e8;
            overflow-x: hidden;
        }

        .header {
            background: linear-gradient(135deg, #1a1f3a 0%, #2a2f4a 100%);
            padding: 20px 40px;
            border-bottom: 2px solid #58a6ff;
            text-align: center;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 300;
            color: #79c0ff;
            letter-spacing: -0.5px;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 450px;
            height: calc(100vh - 84px);
            gap: 0;
        }

        .viz-section {
            background: #000;
            padding: 20px;
            position: relative;
            display: flex;
            flex-direction: column;
        }

        .viz-info {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(26, 31, 58, 0.95);
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid #58a6ff;
            z-index: 10;
        }

        .viz-info h3 {
            font-size: 1.2rem;
            color: #79c0ff;
            margin-bottom: 5px;
            font-weight: 400;
        }

        .viz-info p {
            font-size: 0.9rem;
            color: #8b949e;
            margin: 3px 0;
        }

        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #mainCanvas {
            max-width: 100%;
            max-height: 100%;
        }

        .controls-panel {
            background: linear-gradient(180deg, #0f1419 0%, #161b22 100%);
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid #30363d;
        }

        .control-section {
            background: rgba(22, 27, 34, 0.8);
            border: 1px solid #30363d;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .control-section h3 {
            font-size: 1rem;
            color: #79c0ff;
            margin-bottom: 15px;
            font-weight: 500;
            border-bottom: 1px solid #30363d;
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: block;
            font-size: 0.85rem;
            color: #8b949e;
            margin-bottom: 6px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: #30363d;
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: #58a6ff;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: #79c0ff;
            transform: scale(1.2);
        }

        input[type="number"], input[type="text"], select {
            width: 100%;
            padding: 8px 12px;
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 0.9rem;
            outline: none;
        }

        input[type="number"]:focus, input[type="text"]:focus, select:focus {
            border-color: #58a6ff;
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .preset-btn, .action-btn {
            padding: 10px;
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .preset-btn:hover, .action-btn:hover {
            background: linear-gradient(135deg, #30363d 0%, #484f58 100%);
            border-color: #58a6ff;
            transform: translateY(-1px);
        }

        .export-btn {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
            border-color: #2ea043;
            color: white;
            font-weight: 500;
        }

        .export-btn:hover {
            background: linear-gradient(135deg, #2ea043 0%, #3fb950 100%);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 10px;
            cursor: pointer;
            accent-color: #58a6ff;
        }

        .checkbox-group label {
            font-size: 0.9rem;
            color: #c9d1d9;
            cursor: pointer;
        }

        .value-display {
            display: inline-block;
            background: #0d1117;
            padding: 4px 10px;
            border-radius: 4px;
            color: #79c0ff;
            font-size: 0.85rem;
            margin-left: 10px;
            font-family: 'Courier New', monospace;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .stats-table td {
            padding: 8px;
            border: 1px solid #30363d;
            font-size: 0.85rem;
        }

        .stats-table td:first-child {
            color: #8b949e;
            width: 45%;
        }

        .stats-table td:last-child {
            color: #79c0ff;
            text-align: right;
            font-family: 'Courier New', monospace;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            background: #58a6ff;
            color: #0a0e27;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-top: 10px;
        }

        .animation-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .play-btn {
            background: linear-gradient(135deg, #1f6feb 0%, #388bfd 100%);
            color: white;
            font-weight: 500;
        }

        .stop-btn {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
            color: white;
            font-weight: 500;
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
            
            .controls-panel {
                height: 400px;
                border-left: none;
                border-top: 1px solid #30363d;
            }
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #0d1117;
        }

        ::-webkit-scrollbar-thumb {
            background: #30363d;
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #484f58;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Modular Reduction Projection Explorer</h1>
    </div>

    <div class="main-container">
        <div class="viz-section">
            <div class="viz-info" id="vizInfo">
                <h3>M = <span id="currentM">32</span></h3>
                <p>Prime Factorization: <span id="primeFactorization">2⁵</span></p>
            </div>
            <div id="canvas-container">
                <svg id="mainCanvas" width="800" height="800" viewBox="-500 -500 1000 1000"></svg>
            </div>
        </div>

        <div class="controls-panel">
            <!-- MODULUS CONFIGURATION -->
            <div class="control-section">
                <h3>Modulus Configuration</h3>
                <div class="control-group">
                    <label class="control-label">
                        Modulus M <span class="value-display" id="modulusValue">32</span>
                    </label>
                    <input type="range" id="modulusSlider" min="2" max="5000" value="32">
                </div>
                <div class="control-group">
                    <label class="control-label">Manual Input (2-10000)</label>
                    <input type="number" id="modulusInput" min="2" max="10000" value="32">
                </div>
                <div class="preset-buttons">
                    <button class="preset-btn" onclick="setModulus(12)">12</button>
                    <button class="preset-btn" onclick="setModulus(30)">30</button>
                    <button class="preset-btn" onclick="setModulus(60)">60</button>
                    <button class="preset-btn" onclick="setModulus(210)">210</button>
                    <button class="preset-btn" onclick="setModulus(420)">420</button>
                    <button class="preset-btn" onclick="setModulus(2310)">2310</button>
                    <button class="preset-btn" onclick="setModulus(17)">17 Prime</button>
                    <button class="preset-btn" onclick="setModulus(101)">101 Prime</button>
                    <button class="preset-btn" onclick="setModulus(1024)">2¹⁰=1024</button>
                </div>
            </div>

            <!-- ANIMATION CONTROLS -->
            <div class="control-section">
                <h3>Animation Controls</h3>
                <div class="animation-controls">
                    <button class="preset-btn play-btn" onclick="startAnimation()">▶ Play</button>
                    <button class="preset-btn stop-btn" onclick="stopAnimation()">⏸ Stop</button>
                </div>
                <div class="control-group" style="margin-top: 15px;">
                    <label class="control-label">
                        Speed (ms) <span class="value-display" id="speedValue">500</span>
                    </label>
                    <input type="range" id="animSpeed" min="50" max="2000" value="500">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="loopAnim" checked>
                    <label for="loopAnim">Loop Animation</label>
                </div>
            </div>

            <!-- DISPLAY OPTIONS -->
            <div class="control-section">
                <h3>Display Options</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="showProjections" checked onchange="render()">
                    <label for="showProjections">Projection Lines</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showChannels" checked onchange="render()">
                    <label for="showChannels">Channel Rings</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showAllRingPoints" checked onchange="render()">
                    <label for="showAllRingPoints">Show All Ring Points</label>
                </div>
                <div class="control-group">
                    <label class="control-label">Point Color Mode</label>
                    <select id="pointColorMode" onchange="render()">
                        <option value="coprime">Coprime vs Non-coprime</option>
                        <option value="byring">Color by Ring</option>
                        <option value="bygcd">Color by GCD</option>
                        <option value="rainbow">Rainbow Spectrum</option>
                        <option value="custom">Custom Colors</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">Farey Line Color Mode</label>
                    <select id="fareyColorMode" onchange="render()">
                        <option value="red">Solid Red</option>
                        <option value="gold">Gold (Classic)</option>
                        <option value="bygcd">Color by GCD</option>
                        <option value="bydepth">Color by Depth</option>
                        <option value="gradient">Gradient</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Farey Line Thickness <span class="value-display" id="fareyThickValue">1.0</span>
                    </label>
                    <input type="range" id="fareyThickness" min="0.1" max="5.0" step="0.1" value="1.0" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">Constellation Highlight</label>
                    <select id="constellation" onchange="render()">
                        <option value="none">None</option>
                        <option value="twin">Twin Primes (gap=2)</option>
                        <option value="cousin">Cousin Primes (gap=4)</option>
                        <option value="sexy">Sexy Primes (gap=6)</option>
                        <option value="gap8">Gap-8 Pairs</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">Filter Residues</label>
                    <select id="filterMode" onchange="render()">
                        <option value="all">All Residues</option>
                        <option value="coprime">Coprime Only</option>
                        <option value="noncoprime">Non-coprime Only</option>
                    </select>
                </div>
            </div>

            <!-- LABELING OPTIONS -->
            <div class="control-section">
                <h3>Labeling Options</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="showLabels" onchange="render()">
                    <label for="showLabels">Show Point Labels</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="labelAllRings" onchange="render()">
                    <label for="labelAllRings">Label All Rings</label>
                </div>
                <div class="control-group">
                    <label class="control-label">Label Mode</label>
                    <select id="labelMode" onchange="render()">
                        <option value="residue">Residue (r)</option>
                        <option value="fraction">Fraction (r/M)</option>
                        <option value="gcd">GCD Value</option>
                        <option value="channel">Channel (M')</option>
                        <option value="angle">Angle (degrees)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Label Size (px) <span class="value-display" id="labelSizeValue">12</span>
                    </label>
                    <input type="range" id="labelSize" min="8" max="24" value="12" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Label Distance <span class="value-display" id="labelDistValue">1.25</span>
                    </label>
                    <input type="range" id="labelDist" min="1.0" max="2.5" step="0.05" value="1.25" onchange="render()">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="labelCoprimeOnly" onchange="render()">
                    <label for="labelCoprimeOnly">Label Coprimes Only</label>
                </div>
                <div class="control-group">
                    <label class="control-label">Label Every Nth Point (Outer Ring)</label>
                    <input type="number" id="labelEveryN" min="1" max="100" value="1" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">Label Every Nth Point (Inner Rings)</label>
                    <input type="number" id="labelEveryNInner" min="1" max="100" value="1" onchange="render()">
                </div>
            </div>

            <!-- VIEW CONTROLS -->
            <div class="control-section">
                <h3>View Controls</h3>
                <div class="control-group">
                    <label class="control-label">
                        Zoom <span class="value-display" id="zoomValue">1.00</span>×
                    </label>
                    <input type="range" id="zoom" min="0.1" max="5.0" step="0.1" value="1.0" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Global Rotation <span class="value-display" id="rotationValue">0</span>°
                    </label>
                    <input type="range" id="rotation" min="0" max="360" value="0" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Per-Ring Rotation <span class="value-display" id="ringRotValue">0.0</span>°
                    </label>
                    <input type="range" id="ringRotation" min="0" max="720" step="0.5" value="0" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">Per-Ring Rotation (Manual)</label>
                    <input type="number" id="ringRotInput" min="0" max="3600" step="1" value="0">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Line Thickness <span class="value-display" id="lineThickValue">1.00</span>
                    </label>
                    <input type="range" id="lineThick" min="0.1" max="3.0" step="0.1" value="1.0" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Point Size <span class="value-display" id="pointSizeValue">6.0</span>px
                    </label>
                    <input type="range" id="pointSize" min="2" max="20" step="0.5" value="6" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Opacity <span class="value-display" id="opacityValue">100</span>%
                    </label>
                    <input type="range" id="opacity" min="0" max="100" value="100" onchange="render()">
                </div>
            </div>

            <!-- STATISTICS -->
            <div class="control-section">
                <h3>Statistics</h3>
                <table class="stats-table">
                    <tr><td>Modulus M</td><td id="statM">32</td></tr>
                    <tr><td>φ(M)</td><td id="statPhi">16</td></tr>
                    <tr><td>Coprime</td><td id="statCoprime">16</td></tr>
                    <tr><td>Non-coprime</td><td id="statNonCoprime">16</td></tr>
                    <tr><td>Channels</td><td id="statChannels">6</td></tr>
                    <tr><td>Density</td><td id="statDensity">50.0%</td></tr>
                    <tr><td>Class</td><td id="statClass">Composite</td></tr>
                </table>
                <div style="text-align: center;">
                    <span class="badge" id="omegaBadge">ω(M)=1</span>
                </div>
            </div>

            <!-- DATA EXPORT -->
            <div class="control-section">
                <h3>Data Export</h3>
                <div class="control-group">
                    <label class="control-label">Export Resolution (px)</label>
                    <input type="number" id="exportRes" min="1000" max="8000" value="3000">
                </div>
                <div class="preset-buttons">
                    <button class="preset-btn export-btn" onclick="exportPNG()">PNG</button>
                    <button class="preset-btn export-btn" onclick="exportCSV()">CSV</button>
                    <button class="preset-btn export-btn" onclick="exportJSON()">JSON</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let M = 32;
        let currentData = null;
        let animationInterval = null;

        // Mathematical functions
        function gcd(a, b) {
            while (b) {
                const temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }

        function eulerPhi(n) {
            let result = n;
            let temp = n;
            for (let p = 2; p * p <= temp; p++) {
                if (temp % p === 0) {
                    while (temp % p === 0) temp /= p;
                    result -= result / p;
                }
            }
            if (temp > 1) result -= result / temp;
            return Math.round(result);
        }

        function primeFactorization(n) {
            const factors = {};
            let temp = n;
            for (let i = 2; i <= temp; i++) {
                while (temp % i === 0) {
                    factors[i] = (factors[i] || 0) + 1;
                    temp /= i;
                }
            }
            return factors;
        }

        function formatPrimeFactorization(n) {
            const factors = primeFactorization(n);
            const parts = [];
            for (const [prime, power] of Object.entries(factors)) {
                if (power === 1) parts.push(prime);
                else parts.push(`${prime}${String.fromCharCode(0x2070 + parseInt(power))}`);
            }
            return parts.join('×') || '1';
        }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i * i <= n; i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }

        // Calculate modular structure
        function calculate(modulus) {
            const residues = [];
            const phi = eulerPhi(modulus);
            const divisors = [];
            
            for (let d = 1; d < modulus; d++) {
                if (modulus % d === 0) divisors.push(d);
            }

            for (let r = 0; r < modulus; r++) {
                const g = gcd(r, modulus);
                const coprime = g === 1;
                const channel = modulus / g;
                const angle = -Math.PI / 2 + (2 * Math.PI * r / modulus);
                
                residues.push({
                    r,
                    gcd: g,
                    coprime,
                    channel,
                    angle,
                    x: 400 * Math.cos(angle),
                    y: 400 * Math.sin(angle)
                });
            }

            return {
                M: modulus,
                phi,
                residues,
                divisors,
                isPrime: isPrime(modulus),
                omega: Object.keys(primeFactorization(modulus)).length
            };
        }

        // Get color for point based on mode
        function getPointColor(residue, ring, ringIndex, mode) {
            const { r, coprime, gcd: g } = residue;
            
            switch(mode) {
                case 'coprime':
                    return coprime ? '#00ffff' : '#ff1493';
                case 'byring':
                    const ringHue = (ringIndex * 40) % 360;
                    return `hsl(${ringHue}, 80%, 60%)`;
                case 'bygcd':
                    const gcdHue = (g * 60) % 360;
                    return `hsl(${gcdHue}, 80%, 60%)`;
                case 'rainbow':
                    const hue = (r / ring) * 360;
                    return `hsl(${hue}, 80%, 60%)`;
                case 'custom':
                    if (coprime) return '#00ffff';
                    return `hsl(${(ringIndex * 30) % 360}, 70%, 50%)`;
                default:
                    return coprime ? '#00ffff' : '#ff1493';
            }
        }

        // Get color for Farey line
        function getFareyLineColor(sourceRes, targetRingIndex, mode) {
            switch(mode) {
                case 'red':
                    return '#ff0000';
                case 'gold':
                    return '#ffd700';
                case 'bygcd':
                    const gcdHue = (sourceRes.gcd * 60) % 360;
                    return `hsl(${gcdHue}, 80%, 60%)`;
                case 'bydepth':
                    const depthHue = 200 + targetRingIndex * 20;
                    return `hsl(${depthHue}, 80%, 60%)`;
                case 'gradient':
                    return '#ff6b6b';
                default:
                    return '#ff0000';
            }
        }

        // Render visualization
        function render() {
            if (!currentData) return;

            const svg = document.getElementById('mainCanvas');
            svg.innerHTML = '';

            const zoom = parseFloat(document.getElementById('zoom').value);
            const rotation = parseFloat(document.getElementById('rotation').value);
            const ringRotation = parseFloat(document.getElementById('ringRotation').value);
            const lineThick = parseFloat(document.getElementById('lineThick').value);
            const pointSize = parseFloat(document.getElementById('pointSize').value);
            const opacity = parseFloat(document.getElementById('opacity').value) / 100;
            const showProjections = document.getElementById('showProjections').checked;
            const showChannels = document.getElementById('showChannels').checked;
            const showAllRingPoints = document.getElementById('showAllRingPoints').checked;
            const pointColorMode = document.getElementById('pointColorMode').value;
            const fareyColorMode = document.getElementById('fareyColorMode').value;
            const fareyThickness = parseFloat(document.getElementById('fareyThickness').value);
            const showLabels = document.getElementById('showLabels').checked;
            const labelAllRings = document.getElementById('labelAllRings').checked;
            const labelMode = document.getElementById('labelMode').value;
            const labelSize = parseFloat(document.getElementById('labelSize').value);
            const labelDist = parseFloat(document.getElementById('labelDist').value);
            const labelCoprimeOnly = document.getElementById('labelCoprimeOnly').checked;
            const labelEveryN = parseInt(document.getElementById('labelEveryN').value);
            const labelEveryNInner = parseInt(document.getElementById('labelEveryNInner').value);
            const filterMode = document.getElementById('filterMode').value;

            // Convert ring rotation to radians
            const ringRotRad = (ringRotation * Math.PI) / 180;

            // Create main group with transform
            const mainG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            mainG.setAttribute('transform', `scale(${zoom}) rotate(${rotation})`);

            // Build ring structure: for each divisor of M, create a ring
            const divisors = [];
            for (let d = 1; d <= M; d++) {
                if (M % d === 0) divisors.push(d);
            }
            
            const sortedDivisors = [...divisors].sort((a, b) => a - b);
            const ringIndexMap = {};
            sortedDivisors.forEach((d, idx) => {
                ringIndexMap[d] = idx;
            });

            // Draw channel rings with per-ring rotation
            if (showChannels) {
                sortedDivisors.forEach((d, ringIndex) => {
                    const radius = 400 * (d / M);
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', 0);
                    circle.setAttribute('cy', 0);
                    circle.setAttribute('r', radius);
                    circle.setAttribute('fill', 'none');
                    circle.setAttribute('stroke', '#30363d');
                    circle.setAttribute('stroke-width', lineThick);
                    circle.setAttribute('opacity', 0.5 * opacity);
                    mainG.appendChild(circle);
                });
            }

            // Calculate all points on all rings
            const allRingPoints = [];
            sortedDivisors.forEach((divisor, ringIndex) => {
                const radius = 400 * (divisor / M);
                const ringRotationAngle = ringRotRad * ringIndex;
                
                for (let k = 0; k < divisor; k++) {
                    const baseAngle = -Math.PI / 2 + (2 * Math.PI * k / divisor);
                    const angle = baseAngle + ringRotationAngle;
                    const x = radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);
                    
                    const g = gcd(k, divisor);
                    const coprime = g === 1;
                    
                    allRingPoints.push({
                        ring: divisor,
                        ringIndex,
                        r: k,
                        x, y,
                        angle,
                        baseAngle,
                        radius,
                        gcd: g,
                        coprime,
                        channel: divisor / g
                    });
                }
            });

            // Draw Farey projection lines first (so they're behind points)
            if (showProjections) {
                allRingPoints.forEach(point => {
                    if (point.gcd > 1) {
                        // Find target ring (channel)
                        const targetRing = point.channel;
                        const targetRingIndex = ringIndexMap[targetRing];
                        
                        if (targetRingIndex !== undefined) {
                            const targetRadius = 400 * (targetRing / M);
                            const targetRotation = ringRotRad * targetRingIndex;
                            const targetAngle = point.baseAngle + targetRotation;
                            const targetX = targetRadius * Math.cos(targetAngle);
                            const targetY = targetRadius * Math.sin(targetAngle);
                            
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', point.x);
                            line.setAttribute('y1', point.y);
                            line.setAttribute('x2', targetX);
                            line.setAttribute('y2', targetY);
                            line.setAttribute('stroke', getFareyLineColor(point, targetRingIndex, fareyColorMode));
                            line.setAttribute('stroke-width', fareyThickness);
                            line.setAttribute('opacity', 0.5 * opacity);
                            mainG.appendChild(line);
                        }
                    }
                });
            }

            // Draw all points on all rings
            if (showAllRingPoints) {
                allRingPoints.forEach(point => {
                    // Apply filter only to outer ring
                    if (point.ring === M) {
                        if (filterMode === 'coprime' && !point.coprime) return;
                        if (filterMode === 'noncoprime' && point.coprime) return;
                    }

                    const color = getPointColor(point, point.ring, point.ringIndex, pointColorMode);
                    const size = point.coprime ? pointSize : pointSize * 0.7;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', point.x);
                    circle.setAttribute('cy', point.y);
                    circle.setAttribute('r', size);
                    circle.setAttribute('fill', color);
                    circle.setAttribute('opacity', opacity);
                    mainG.appendChild(circle);
                });
            }

            // Draw labels
            if (showLabels) {
                allRingPoints.forEach((point, idx) => {
                    // Decide if we should label this point
                    const isOuterRing = point.ring === M;
                    const shouldLabelRing = isOuterRing || labelAllRings;
                    
                    if (!shouldLabelRing) return;
                    
                    // Apply Nth point filter
                    const nthFilter = isOuterRing ? labelEveryN : labelEveryNInner;
                    if (point.r % nthFilter !== 0) return;
                    
                    // Apply coprime filter
                    if (labelCoprimeOnly && !point.coprime) return;
                    
                    // Apply general filter only to outer ring
                    if (isOuterRing) {
                        if (filterMode === 'coprime' && !point.coprime) return;
                        if (filterMode === 'noncoprime' && point.coprime) return;
                    }
                    
                    let labelText = '';
                    switch(labelMode) {
                        case 'residue': 
                            labelText = point.r.toString(); 
                            break;
                        case 'fraction': 
                            const reduced = gcd(point.r, point.ring);
                            const num = point.r / reduced;
                            const den = point.ring / reduced;
                            labelText = den === 1 ? num.toString() : `${num}/${den}`;
                            break;
                        case 'gcd': 
                            labelText = point.gcd.toString(); 
                            break;
                        case 'channel': 
                            labelText = point.channel.toString(); 
                            break;
                        case 'angle': 
                            labelText = Math.round(((point.baseAngle + Math.PI/2) * 180 / Math.PI) % 360) + '°'; 
                            break;
                    }
                    
                    // Position label OUTSIDE the ring
                    const labelRadius = point.radius + (labelDist * 20);
                    const labelX = labelRadius * Math.cos(point.angle);
                    const labelY = labelRadius * Math.sin(point.angle);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', labelX);
                    text.setAttribute('y', labelY);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('fill', '#c9d1d9');
                    text.setAttribute('font-size', labelSize);
                    text.setAttribute('opacity', opacity);
                    text.textContent = labelText;
                    mainG.appendChild(text);
                });
            }

            svg.appendChild(mainG);
            updateStatistics();
        }

        // Update statistics display
        function updateStatistics() {
            if (!currentData) return;
            
            document.getElementById('statM').textContent = currentData.M;
            document.getElementById('statPhi').textContent = currentData.phi;
            document.getElementById('statCoprime').textContent = currentData.residues.filter(r => r.coprime).length;
            document.getElementById('statNonCoprime').textContent = currentData.residues.filter(r => !r.coprime).length;
            document.getElementById('statChannels').textContent = currentData.divisors.length;
            document.getElementById('statDensity').textContent = ((currentData.phi / currentData.M) * 100).toFixed(1) + '%';
            document.getElementById('statClass').textContent = currentData.isPrime ? 'Prime' : 'Composite';
            document.getElementById('omegaBadge').textContent = currentData.isPrime ? 'Prime' : `ω(M)=${currentData.omega}`;
        }

        // Set modulus
        function setModulus(value) {
            M = value;
            document.getElementById('modulusSlider').value = value;
            document.getElementById('modulusInput').value = value;
            document.getElementById('modulusValue').textContent = value;
            document.getElementById('currentM').textContent = value;
            document.getElementById('primeFactorization').textContent = formatPrimeFactorization(value);
            
            currentData = calculate(M);
            render();
        }

        // Animation
        function startAnimation() {
            if (animationInterval) return;
            
            const speed = parseInt(document.getElementById('animSpeed').value);
            const loop = document.getElementById('loopAnim').checked;
            let current = M;
            
            animationInterval = setInterval(() => {
                current++;
                if (current > 200 && loop) current = 2;
                if (current > 200 && !loop) {
                    stopAnimation();
                    return;
                }
                setModulus(current);
            }, speed);
        }

        function stopAnimation() {
            if (animationInterval) {
                clearInterval(animationInterval);
                animationInterval = null;
            }
        }

        // Export functions
        function exportPNG() {
            const svg = document.getElementById('mainCanvas');
            const serializer = new XMLSerializer();
            const svgStr = serializer.serializeToString(svg);
            const canvas = document.createElement('canvas');
            const resolution = parseInt(document.getElementById('exportRes').value);
            canvas.width = resolution;
            canvas.height = resolution;
            const ctx = canvas.getContext('2d');
            
            const img = new Image();
            const blob = new Blob([svgStr], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            img.onload = function() {
                ctx.fillStyle = '#000';
                ctx.fillRect(0, 0, resolution, resolution);
                ctx.drawImage(img, 0, 0, resolution, resolution);
                URL.revokeObjectURL(url);
                
                canvas.toBlob(blob => {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    a.download = `modular-M${M}-${Date.now()}.png`;
                    a.click();
                });
            };
            img.src = url;
        }

        function exportCSV() {
            let csv = 'r,M,gcd,coprime,angle_rad,angle_deg,channel,x,y\n';
            currentData.residues.forEach(res => {
                const angleDeg = ((res.angle + Math.PI/2) * 180 / Math.PI) % 360;
                csv += `${res.r},${M},${res.gcd},${res.coprime},${res.angle.toFixed(6)},${angleDeg.toFixed(2)},${res.channel},${res.x.toFixed(2)},${res.y.toFixed(2)}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `modular-M${M}-${Date.now()}.csv`;
            a.click();
        }

        function exportJSON() {
            const data = {
                metadata: { M, timestamp: new Date().toISOString(), version: '2.0' },
                statistics: {
                    phi: currentData.phi,
                    coprime_count: currentData.residues.filter(r => r.coprime).length,
                    density: currentData.phi / M,
                    is_prime: currentData.isPrime,
                    omega: currentData.omega
                },
                residues: currentData.residues
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `modular-M${M}-${Date.now()}.json`;
            a.click();
        }

        // Event listeners
        document.getElementById('modulusSlider').addEventListener('input', (e) => {
            setModulus(parseInt(e.target.value));
        });

        document.getElementById('modulusInput').addEventListener('change', (e) => {
            const value = Math.max(2, Math.min(10000, parseInt(e.target.value) || 2));
            setModulus(value);
        });

        document.getElementById('animSpeed').addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = e.target.value;
        });

        document.getElementById('zoom').addEventListener('input', (e) => {
            document.getElementById('zoomValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('rotation').addEventListener('input', (e) => {
            document.getElementById('rotationValue').textContent = e.target.value;
        });

        document.getElementById('ringRotation').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('ringRotValue').textContent = value.toFixed(1);
            document.getElementById('ringRotInput').value = Math.round(value);
        });

        document.getElementById('ringRotInput').addEventListener('change', (e) => {
            const value = Math.max(0, Math.min(3600, parseFloat(e.target.value) || 0));
            document.getElementById('ringRotation').value = value;
            document.getElementById('ringRotValue').textContent = value.toFixed(1);
            render();
        });

        document.getElementById('fareyThickness').addEventListener('input', (e) => {
            document.getElementById('fareyThickValue').textContent = parseFloat(e.target.value).toFixed(1);
        });

        document.getElementById('lineThick').addEventListener('input', (e) => {
            document.getElementById('lineThickValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('pointSize').addEventListener('input', (e) => {
            document.getElementById('pointSizeValue').textContent = parseFloat(e.target.value).toFixed(1);
        });

        document.getElementById('opacity').addEventListener('input', (e) => {
            document.getElementById('opacityValue').textContent = e.target.value;
        });

        document.getElementById('labelSize').addEventListener('input', (e) => {
            document.getElementById('labelSizeValue').textContent = e.target.value;
        });

        document.getElementById('labelDist').addEventListener('input', (e) => {
            document.getElementById('labelDistValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        // Initialize
        setModulus(32);
    </script>
</body>
</html>
