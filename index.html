
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modular Reduction Projection Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #0a0e27;
            --bg-secondary: #1a1f3a;
            --bg-tertiary: #0f1419;
            --bg-quaternary: #161b22;
            --text-primary: #e8e8e8;
            --text-secondary: #c9d1d9;
            --text-tertiary: #8b949e;
            --border-color: #30363d;
            --accent-color: #58a6ff;
            --accent-hover: #79c0ff;
            --input-bg: #0d1117;
            --control-bg: rgba(22, 27, 34, 0.8);
        }

        body.light-mode {
            --bg-primary: #f6f8fa;
            --bg-secondary: #ffffff;
            --bg-tertiary: #e8eaed;
            --bg-quaternary: #ffffff;
            --text-primary: #1f2328;
            --text-secondary: #2d333b;
            --text-tertiary: #656d76;
            --border-color: #d0d7de;
            --accent-color: #0969da;
            --accent-hover: #0550ae;
            --input-bg: #ffffff;
            --control-bg: rgba(255, 255, 255, 0.9);
        }

        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 50%, var(--bg-primary) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            transition: all 0.3s ease;
        }

        .header {
            background: linear-gradient(135deg, var(--bg-secondary) 0%, var(--bg-quaternary) 100%);
            padding: 20px 40px;
            border-bottom: 2px solid var(--accent-color);
            text-align: center;
        }

        .header h1 {
            font-size: 1.8rem;
            font-weight: 300;
            color: var(--accent-hover);
            letter-spacing: -0.5px;
        }

        .main-container {
            display: grid;
            grid-template-columns: 1fr 450px;
            height: calc(100vh - 84px);
            gap: 0;
        }

        .viz-section {
            background: #000;
            padding: 20px;
            position: relative;
            display: flex;
            flex-direction: column;
            transition: background 0.3s ease;
        }

        .viz-section.canvas-bg-white { background: #ffffff; }
        .viz-section.canvas-bg-black { background: #000000; }
        .viz-section.canvas-bg-darkgray { background: #2a2a2a; }
        .viz-section.canvas-bg-lightgray { background: #e0e0e0; }
        .viz-section.canvas-bg-navy { background: #001f3f; }
        .viz-section.canvas-bg-transparent { background: transparent; }

        .viz-info {
            position: absolute;
            top: 30px;
            left: 30px;
            background: rgba(26, 31, 58, 0.95);
            padding: 15px 20px;
            border-radius: 8px;
            border: 1px solid var(--accent-color);
            z-index: 10;
        }

        body.light-mode .viz-info {
            background: rgba(255, 255, 255, 0.95);
            border: 1px solid var(--border-color);
        }

        .viz-info h3 {
            font-size: 1.2rem;
            color: var(--accent-hover);
            margin-bottom: 5px;
            font-weight: 400;
        }

        .viz-info p {
            font-size: 0.9rem;
            color: var(--text-tertiary);
            margin: 3px 0;
        }

        #canvas-container {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        #mainCanvas {
            max-width: 100%;
            max-height: 100%;
        }

        .controls-panel {
            background: linear-gradient(180deg, var(--bg-tertiary) 0%, var(--bg-quaternary) 100%);
            padding: 20px;
            overflow-y: auto;
            border-left: 1px solid var(--border-color);
        }

        .control-section {
            background: var(--control-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .control-section h3 {
            font-size: 1rem;
            color: var(--accent-hover);
            margin-bottom: 15px;
            font-weight: 500;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 8px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-label {
            display: block;
            font-size: 0.85rem;
            color: var(--text-tertiary);
            margin-bottom: 6px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--border-color);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent-color);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            background: var(--accent-hover);
            transform: scale(1.2);
        }

        input[type="number"], input[type="text"], input[type="color"], select {
            width: 100%;
            padding: 8px 12px;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 0.9rem;
            outline: none;
        }

        input[type="number"]:focus, input[type="text"]:focus, select:focus {
            border-color: var(--accent-color);
        }

        .preset-buttons {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-top: 10px;
        }

        .preset-btn, .action-btn {
            padding: 10px;
            background: linear-gradient(135deg, #21262d 0%, #30363d 100%);
            border: 1px solid #30363d;
            border-radius: 6px;
            color: #c9d1d9;
            font-size: 0.85rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .preset-btn:hover, .action-btn:hover {
            background: linear-gradient(135deg, #30363d 0%, #484f58 100%);
            border-color: #58a6ff;
            transform: translateY(-1px);
        }

        .export-btn {
            background: linear-gradient(135deg, #238636 0%, #2ea043 100%);
            border-color: #2ea043;
            color: white;
            font-weight: 500;
        }

        .export-btn:hover {
            background: linear-gradient(135deg, #2ea043 0%, #3fb950 100%);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }

        input[type="checkbox"] {
            width: 18px;
            height: 18px;
            margin-right: 10px;
            cursor: pointer;
            accent-color: #58a6ff;
        }

        .checkbox-group label {
            font-size: 0.9rem;
            color: #c9d1d9;
            cursor: pointer;
        }

        .value-display {
            display: inline-block;
            background: #0d1117;
            padding: 4px 10px;
            border-radius: 4px;
            color: #79c0ff;
            font-size: 0.85rem;
            margin-left: 10px;
            font-family: 'Courier New', monospace;
        }

        .stats-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }

        .stats-table td {
            padding: 8px;
            border: 1px solid #30363d;
            font-size: 0.85rem;
        }

        .stats-table td:first-child {
            color: #8b949e;
            width: 45%;
        }

        .stats-table td:last-child {
            color: #79c0ff;
            text-align: right;
            font-family: 'Courier New', monospace;
        }

        .badge {
            display: inline-block;
            padding: 4px 12px;
            background: #58a6ff;
            color: #0a0e27;
            border-radius: 12px;
            font-size: 0.8rem;
            font-weight: 500;
            margin-top: 10px;
        }

        .channel-item {
            background: rgba(30, 36, 56, 0.5);
            border: 1px solid #30363d;
            border-radius: 6px;
            padding: 12px;
            margin-bottom: 10px;
        }

        .channel-header {
            font-size: 0.95rem;
            color: #79c0ff;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .channel-formula {
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            color: #c9d1d9;
            margin: 4px 0;
        }

        .channel-ratio {
            font-size: 0.85rem;
            color: #8b949e;
            margin-top: 6px;
        }

        .angle-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .angle-chip {
            background: #0d1117;
            border: 1px solid #30363d;
            border-radius: 4px;
            padding: 4px 8px;
            font-size: 0.75rem;
            color: #79c0ff;
            font-family: 'Courier New', monospace;
        }

        .animation-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }

        .play-btn {
            background: linear-gradient(135deg, #1f6feb 0%, #388bfd 100%);
            color: white;
            font-weight: 500;
        }

        .stop-btn {
            background: linear-gradient(135deg, #da3633 0%, #f85149 100%);
            color: white;
            font-weight: 500;
        }

        @media (max-width: 1200px) {
            .main-container {
                grid-template-columns: 1fr;
            }
            
            .controls-panel {
                height: 400px;
                border-left: none;
                border-top: 1px solid #30363d;
            }
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #0d1117;
        }

        ::-webkit-scrollbar-thumb {
            background: #30363d;
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #484f58;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>Modular Reduction Projection Explorer</h1>
    </div>

    <div class="main-container">
        <div class="viz-section">
            <div class="viz-info" id="vizInfo">
                <h3>M = <span id="currentM">32</span></h3>
                <p>Prime Factorization: <span id="primeFactorization">2‚Åµ</span></p>
            </div>
            <div id="canvas-container">
                <svg id="mainCanvas" width="800" height="800" viewBox="-500 -500 1000 1000"></svg>
            </div>
        </div>

        <div class="controls-panel">
            <!-- MODULUS CONFIGURATION -->
            <div class="control-section">
                <h3>Modulus Configuration</h3>
                <div class="control-group">
                    <label class="control-label">
                        Modulus M <span class="value-display" id="modulusValue">32</span>
                    </label>
                    <input type="range" id="modulusSlider" min="2" max="5000" value="32">
                </div>
                <div class="control-group">
                    <label class="control-label">Manual Input (2-10000)</label>
                    <input type="number" id="modulusInput" min="2" max="10000" value="32">
                </div>
                <div class="preset-buttons">
                    <button class="preset-btn" onclick="setModulus(12)">12</button>
                    <button class="preset-btn" onclick="setModulus(30)">30</button>
                    <button class="preset-btn" onclick="setModulus(60)">60</button>
                    <button class="preset-btn" onclick="setModulus(210)">210</button>
                    <button class="preset-btn" onclick="setModulus(420)">420</button>
                    <button class="preset-btn" onclick="setModulus(2310)">2310</button>
                    <button class="preset-btn" onclick="setModulus(17)">17 Prime</button>
                    <button class="preset-btn" onclick="setModulus(101)">101 Prime</button>
                    <button class="preset-btn" onclick="setModulus(1024)">2¬π‚Å∞=1024</button>
                </div>
            </div>

            <!-- ANIMATION CONTROLS -->
            <div class="control-section">
                <h3>Animation Controls</h3>
                <div class="animation-controls">
                    <button class="preset-btn play-btn" onclick="startAnimation()">‚ñ∂ Play</button>
                    <button class="preset-btn stop-btn" onclick="stopAnimation()">‚è∏ Stop</button>
                </div>
                <div class="control-group" style="margin-top: 15px;">
                    <label class="control-label">Animation Mode</label>
                    <select id="animMode">
                        <option value="increment">Increment M</option>
                        <option value="decrement">Decrement M</option>
                        <option value="rotate">Rotate Rings</option>
                        <option value="rotateGlobal">Rotate Global</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Frame Delay (ms) <span class="value-display" id="speedValue">500</span>
                    </label>
                    <input type="range" id="animSpeed" min="50" max="2000" step="50" value="500">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Speed Multiplier <span class="value-display" id="speedMultValue">1.0</span>√ó
                    </label>
                    <input type="range" id="speedMultiplier" min="0.1" max="5.0" step="0.1" value="1.0">
                </div>
                <div class="control-group">
                    <label class="control-label">Animation Range</label>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                        <input type="number" id="animStart" min="2" max="10000" value="2" placeholder="Start">
                        <input type="number" id="animEnd" min="2" max="10000" value="200" placeholder="End">
                    </div>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="loopAnim" checked>
                    <label for="loopAnim">Loop Animation</label>
                </div>
                
                <!-- RECORDING CONTROLS -->
                <div style="border-top: 1px solid var(--border-color); margin-top: 15px; padding-top: 15px;">
                    <div class="checkbox-group">
                        <input type="checkbox" id="recordAnimation" onchange="toggleRecordingOptions()">
                        <label for="recordAnimation">Record Animation</label>
                    </div>
                    <div id="recordingOptions" style="display: none; margin-top: 10px;">
                        <div class="checkbox-group">
                            <input type="checkbox" id="recordWithLegend" checked>
                            <label for="recordWithLegend">Include Legend</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="recordWithTitle" checked>
                            <label for="recordWithTitle">Include Title</label>
                        </div>
                        <div class="control-group">
                            <label class="control-label">Recording Resolution</label>
                            <select id="recordResolution">
                                <option value="800">800√ó800 (Fast)</option>
                                <option value="1200" selected>1200√ó1200 (Medium)</option>
                                <option value="1600">1600√ó1600 (High)</option>
                                <option value="2000">2000√ó2000 (Very High)</option>
                            </select>
                        </div>
                        <div class="control-group">
                            <label class="control-label">Max Frames</label>
                            <input type="number" id="maxFrames" min="10" max="500" value="100" placeholder="Max frames">
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                            <button class="preset-btn export-btn" onclick="exportRecordedFrames()" id="exportFramesBtn" disabled>üíæ Save Frames (ZIP)</button>
                            <button class="preset-btn export-btn" onclick="exportAsGIF()" id="exportGifBtn" disabled>üé¨ Export as GIF</button>
                        </div>
                        <div id="recordingStatus" style="margin-top: 10px; font-size: 0.85rem; color: var(--text-tertiary);"></div>
                    </div>
                </div>
            </div>

            <!-- DISPLAY OPTIONS -->
            <div class="control-section">
                <h3>Display Options</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="showProjections" checked onchange="render()">
                    <label for="showProjections">Projection Lines</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showChannels" checked onchange="render()">
                    <label for="showChannels">Channel Rings</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showAllRingPoints" checked onchange="render()">
                    <label for="showAllRingPoints">Show All Ring Points</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="invertMode" onchange="render()">
                    <label for="invertMode">Invert Mode (Inner‚ÜîOuter)</label>
                </div>
                <div class="control-group">
                    <label class="control-label">Point Color Mode</label>
                    <select id="pointColorMode" onchange="render()">
                        <option value="coprime">Coprime vs Non-coprime</option>
                        <option value="byring">Color by Ring</option>
                        <option value="bygcd">Color by GCD</option>
                        <option value="rainbow">Rainbow Spectrum</option>
                        <option value="custom">Custom Colors</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">Farey Line Color Mode</label>
                    <select id="fareyColorMode" onchange="render()">
                        <option value="red">Solid Red</option>
                        <option value="gold">Gold (Classic)</option>
                        <option value="bygcd">Color by GCD</option>
                        <option value="bydepth">Color by Depth</option>
                        <option value="gradient">Gradient</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Farey Line Thickness <span class="value-display" id="fareyThickValue">1.0</span>
                    </label>
                    <input type="range" id="fareyThickness" min="0.1" max="5.0" step="0.1" value="1.0" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">Constellation Highlight</label>
                    <select id="constellation" onchange="render()">
                        <option value="none">None</option>
                        <option value="twin">Twin Primes (gap=2)</option>
                        <option value="cousin">Cousin Primes (gap=4)</option>
                        <option value="sexy">Sexy Primes (gap=6)</option>
                        <option value="gap8">Gap-8 Pairs</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">Filter Residues</label>
                    <select id="filterMode" onchange="render()">
                        <option value="all">All Residues</option>
                        <option value="coprime">Coprime Only</option>
                        <option value="noncoprime">Non-coprime Only</option>
                    </select>
                </div>
            </div>

            <!-- MULTI-MODULUS VIEW -->
            <div class="control-section">
                <h3>Multi-Modulus View</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="enableMultiMod" onchange="toggleMultiMod()">
                    <label for="enableMultiMod">Enable Multi-Modulus Mode</label>
                </div>
                <div id="multiModControls" style="display: none;">
                    <div class="control-group">
                        <label class="control-label">Modulus Range</label>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                            <input type="number" id="multiModStart" min="1" max="1000" value="1" placeholder="Start">
                            <input type="number" id="multiModEnd" min="1" max="1000" value="30" placeholder="End">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Multi-Mod Point Coloring</label>
                        <select id="multiModPointColor" onchange="render()">
                            <option value="coprime">Coprime vs Non-coprime</option>
                            <option value="bymodulus">Color by Modulus (M)</option>
                            <option value="byring">Color by Ring Index</option>
                            <option value="byresidue">Color by Residue (r)</option>
                            <option value="byinteger">Color by Integer (M+r)</option>
                            <option value="bygcd">Color by GCD</option>
                            <option value="density">Color by Density œÜ(M)/M</option>
                            <option value="channel">Color by Farey Channel</option>
                            <option value="primality">Prime vs Composite Moduli</option>
                            <option value="omega">Color by œâ(M)</option>
                            <option value="bigomega">Color by Œ©(M) (with multiplicity)</option>
                            <option value="divisors">Color by # of Divisors</option>
                            <option value="rainbow">Rainbow Spectrum</option>
                            <option value="alternating">Alternating Pattern</option>
                            <option value="gradient">Radial Gradient</option>
                            <option value="heatmap">Heatmap (Inside‚ÜíOutside)</option>
                            <option value="spiral">Spiral Pattern</option>
                            <option value="checkerboard">Checkerboard</option>
                        </select>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Multi-Mod Ring Coloring</label>
                        <select id="multiModRingColor" onchange="render()">
                            <option value="gold">All Gold</option>
                            <option value="bymodulus">Color by Modulus</option>
                            <option value="rainbow">Rainbow</option>
                            <option value="gradient">Gradient (Inside‚ÜíOutside)</option>
                            <option value="primality">Prime vs Composite</option>
                            <option value="omega">By œâ(M) (Prime Factors)</option>
                            <option value="density">By Density œÜ(M)/M</option>
                            <option value="divisors">By # of Divisors</option>
                            <option value="alternating">Alternating Colors</option>
                            <option value="pulse">Pulsing Effect</option>
                            <option value="invisible">Invisible/Hidden</option>
                        </select>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showRtoRConnections" onchange="render()">
                        <label for="showRtoRConnections">Show r-to-r Connections</label>
                    </div>
                    <div class="control-group">
                        <label class="control-label">
                            Gap Connections (2n) <span class="value-display" id="gapSizeValue">2</span>
                        </label>
                        <input type="range" id="gapSize" min="1" max="20" value="2" onchange="render()">
                    </div>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showGapConnections" onchange="render()">
                        <label for="showGapConnections">Show Gap Connections (r to r+2n)</label>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Connection Color Mode</label>
                        <select id="connectionColorMode" onchange="render()">
                            <option value="bygap">Color by Gap</option>
                            <option value="bymod">Color by Modulus</option>
                            <option value="byresidue">Color by Residue</option>
                            <option value="solid">Solid Color</option>
                            <option value="rainbow">Rainbow</option>
                            <option value="gradient">Gradient</option>
                            <option value="pulse">Pulsing Effect</option>
                            <option value="depth">By Connection Depth</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label class="control-label">
                            Connection Thickness <span class="value-display" id="connThickValue">0.5</span>
                        </label>
                        <input type="range" id="connThickness" min="0.1" max="5.0" step="0.1" value="0.5" onchange="render()">
                    </div>
                    <div class="control-group">
                        <label class="control-label">
                            Connection Opacity <span class="value-display" id="connOpacityValue">50</span>%
                        </label>
                        <input type="range" id="connOpacity" min="0" max="100" value="50" onchange="render()">
                    </div>
                    <div class="control-group">
                        <label class="control-label">
                            Ring Spacing <span class="value-display" id="ringSpacingValue">1.0</span>
                        </label>
                        <input type="range" id="ringSpacing" min="0.5" max="3.0" step="0.1" value="1.0" onchange="render()">
                    </div>
                    <button class="preset-btn" onclick="render()" style="width: 100%; margin-top: 10px;">Apply Multi-Mod View</button>
                </div>
            </div>

            <!-- LABELING OPTIONS -->
            <div class="control-section">
                <h3>Labeling Options</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="showLabels" onchange="render()">
                    <label for="showLabels">Show Point Labels</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="labelAllRings" onchange="render()">
                    <label for="labelAllRings">Label All Rings</label>
                </div>
                <div class="control-group">
                    <label class="control-label">Label Mode</label>
                    <select id="labelMode" onchange="render()">
                        <option value="residue">Residue (r)</option>
                        <option value="fraction">Fraction (r/M)</option>
                        <option value="gcd">GCD Value</option>
                        <option value="channel">Channel (M')</option>
                        <option value="angle">Angle (degrees)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Label Size (px) <span class="value-display" id="labelSizeValue">12</span>
                    </label>
                    <input type="range" id="labelSize" min="8" max="24" value="12" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Label Distance <span class="value-display" id="labelDistValue">1.25</span>
                    </label>
                    <input type="range" id="labelDist" min="1.0" max="2.5" step="0.05" value="1.25" onchange="render()">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="labelCoprimeOnly" onchange="render()">
                    <label for="labelCoprimeOnly">Label Coprimes Only</label>
                </div>
                <div class="control-group">
                    <label class="control-label">Label Every Nth Point (Outer Ring)</label>
                    <input type="number" id="labelEveryN" min="1" max="100" value="1" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">Label Every Nth Point (Inner Rings)</label>
                    <input type="number" id="labelEveryNInner" min="1" max="100" value="1" onchange="render()">
                </div>
            </div>

            <!-- VIEW CONTROLS -->
            <div class="control-section">
                <h3>View Controls</h3>
                <div class="control-group">
                    <label class="control-label">Theme</label>
                    <select id="themeMode" onchange="changeTheme()">
                        <option value="dark">Dark Mode</option>
                        <option value="light">Light Mode</option>
                    </select>
                </div>
                <div class="control-group">
                    <label class="control-label">Canvas Background</label>
                    <select id="canvasBg" onchange="render()">
                        <option value="black">Black</option>
                        <option value="white">White</option>
                        <option value="darkgray">Dark Gray</option>
                        <option value="lightgray">Light Gray</option>
                        <option value="navy">Navy</option>
                        <option value="transparent">Transparent</option>
                        <option value="custom">Custom Color</option>
                    </select>
                </div>
                <div class="control-group" id="customBgGroup" style="display: none;">
                    <label class="control-label">Custom Background Color</label>
                    <input type="color" id="customBgColor" value="#000000" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">Ring Color Mode</label>
                    <select id="ringColorMode" onchange="render()">
                        <option value="gold">Gold (Default)</option>
                        <option value="blue">Blue</option>
                        <option value="cyan">Cyan</option>
                        <option value="white">White</option>
                        <option value="gray">Gray</option>
                        <option value="rainbow">Rainbow (by index)</option>
                        <option value="custom">Custom Color</option>
                    </select>
                </div>
                <div class="control-group" id="customRingGroup" style="display: none;">
                    <label class="control-label">Custom Ring Color</label>
                    <input type="color" id="customRingColor" value="#ffd700" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Zoom <span class="value-display" id="zoomValue">1.00</span>√ó
                    </label>
                    <input type="range" id="zoom" min="0.1" max="5.0" step="0.1" value="1.0" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Global Rotation <span class="value-display" id="rotationValue">0</span>¬∞
                    </label>
                    <input type="range" id="rotation" min="0" max="360" value="0" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Per-Ring Rotation <span class="value-display" id="ringRotValue">0.0</span>¬∞
                    </label>
                    <input type="range" id="ringRotation" min="0" max="720" step="0.5" value="0" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">Per-Ring Rotation (Manual)</label>
                    <input type="number" id="ringRotInput" min="0" max="3600" step="1" value="0">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Line Thickness <span class="value-display" id="lineThickValue">1.00</span>
                    </label>
                    <input type="range" id="lineThick" min="0.1" max="3.0" step="0.1" value="1.0" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Point Size <span class="value-display" id="pointSizeValue">6.0</span>px
                    </label>
                    <input type="range" id="pointSize" min="2" max="20" step="0.5" value="6" onchange="render()">
                </div>
                <div class="control-group">
                    <label class="control-label">
                        Opacity <span class="value-display" id="opacityValue">100</span>%
                    </label>
                    <input type="range" id="opacity" min="0" max="100" value="100" onchange="render()">
                </div>
            </div>

            <!-- STATISTICS -->
            <div class="control-section">
                <h3>Statistics</h3>
                <table class="stats-table">
                    <tr><td>Modulus M</td><td id="statM">32</td></tr>
                    <tr><td>œÜ(M)</td><td id="statPhi">16</td></tr>
                    <tr><td>Coprime</td><td id="statCoprime">16</td></tr>
                    <tr><td>Non-coprime</td><td id="statNonCoprime">16</td></tr>
                    <tr><td>Channels</td><td id="statChannels">6</td></tr>
                    <tr><td>Density</td><td id="statDensity">50.0%</td></tr>
                    <tr><td>Class</td><td id="statClass">Composite</td></tr>
                </table>
                <div style="text-align: center;">
                    <span class="badge" id="omegaBadge">œâ(M)=1</span>
                </div>
            </div>

            <!-- ANALYSIS -->
            <div class="control-section">
                <h3>Analysis</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="showAnalysis" onchange="updateAnalysis()">
                    <label for="showAnalysis">Show Detailed Analysis</label>
                </div>
                <div id="analysisPanel" style="display: none; margin-top: 10px;">
                    <div style="background: rgba(30, 36, 56, 0.5); border: 1px solid #30363d; border-radius: 6px; padding: 15px;">
                        <div style="font-size: 1rem; color: #79c0ff; font-weight: 500; margin-bottom: 10px;">
                            Modulus M = <span id="analysisMod">32</span> = <span id="analysisFactorization">2‚Åµ</span>
                        </div>
                        
                        <div style="margin: 15px 0;">
                            <div style="font-size: 0.9rem; color: #c9d1d9; margin: 5px 0;">
                                <span style="color: #79c0ff;">Coprime:</span> <span id="analysisCoprimeCount">16</span> residues (œÜ(M))
                            </div>
                            <div style="font-size: 0.9rem; color: #c9d1d9; margin: 5px 0;">
                                <span style="color: #79c0ff;">Reducible:</span> <span id="analysisReducibleCount">16</span> residues
                            </div>
                            <div style="font-size: 0.9rem; color: #c9d1d9; margin: 5px 0;">
                                <span style="color: #79c0ff;">Ratio:</span> <span id="analysisRatio">50.0%</span> reducible
                            </div>
                        </div>

                        <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #30363d;">
                            <div style="font-size: 0.95rem; color: #79c0ff; font-weight: 500; margin-bottom: 8px;">
                                Farey Channels:
                            </div>
                            <div id="fareyChannelsList" style="font-size: 0.85rem; color: #c9d1d9; line-height: 1.8;">
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- COLOR KEY -->
            <div class="control-section">
                <h3>Color Key</h3>
                <div style="background: rgba(30, 36, 56, 0.5); border: 1px solid #30363d; border-radius: 6px; padding: 15px;">
                    <div style="display: flex; align-items: center; margin: 8px 0;">
                        <div style="width: 20px; height: 20px; background: #00ffff; border-radius: 4px; margin-right: 10px;"></div>
                        <span style="font-size: 0.9rem; color: #c9d1d9;">Cyan = Irreducible (gcd=1)</span>
                    </div>
                    <div style="display: flex; align-items: center; margin: 8px 0;">
                        <div style="width: 20px; height: 20px; background: #ff1493; border-radius: 4px; margin-right: 10px;"></div>
                        <span style="font-size: 0.9rem; color: #c9d1d9;">Red = Reducible (gcd>1)</span>
                    </div>
                    <div style="display: flex; align-items: center; margin: 8px 0;">
                        <div style="width: 20px; height: 20px; background: #ff0000; border-radius: 4px; margin-right: 10px;"></div>
                        <span style="font-size: 0.9rem; color: #c9d1d9;">Red Lines = Farey Channels</span>
                    </div>
                    <div style="display: flex; align-items: center; margin: 8px 0;">
                        <div style="width: 20px; height: 20px; background: #58a6ff; border-radius: 4px; margin-right: 10px;"></div>
                        <span style="font-size: 0.9rem; color: #c9d1d9;">Blue = Outer ring (M circle)</span>
                    </div>
                    <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #30363d; font-size: 0.85rem; color: #8b949e;">
                        Farey Lines: Connect each reducible residue r/M on the outer ring to its reduced form r'/M' on the corresponding inner channel ring.
                    </div>
                </div>
            </div>

            <!-- CHANNEL ANGLES -->
            <div class="control-section">
                <h3>Channel Angles (2œÄr/M)</h3>
                <div class="checkbox-group">
                    <input type="checkbox" id="showChannelInfo" onchange="updateChannelInfo()">
                    <label for="showChannelInfo">Show Channel Details</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="showAngleOverlay" onchange="render()">
                    <label for="showAngleOverlay">Show Angle Overlay on Rings</label>
                </div>
                <div class="control-group">
                    <label class="control-label">Angle Display Format</label>
                    <select id="angleFormat" onchange="render()">
                        <option value="degrees">Degrees (0-360¬∞)</option>
                        <option value="radians">Radians (0-2œÄ)</option>
                        <option value="formula">Formula (2œÄr/M)</option>
                    </select>
                </div>
                <div id="channelInfo" style="display: none; max-height: 300px; overflow-y: auto; margin-top: 10px;">
                    <div style="font-size: 0.85rem; color: #8b949e; margin-bottom: 10px;">
                        For each divisor M' of M, showing angle formula 2œÄr/M' in degrees
                    </div>
                    <div id="channelList"></div>
                </div>
            </div>

            <!-- DATA EXPORT -->
            <div class="control-section">
                <h3>Data Export</h3>
                <div class="control-group">
                    <label class="control-label">Export Resolution (px)</label>
                    <input type="number" id="exportRes" min="1000" max="8000" value="3000">
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="exportWithLegend" checked>
                    <label for="exportWithLegend">Include Legend</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="exportWithTitle" checked>
                    <label for="exportWithTitle">Include Title & Analysis</label>
                </div>
                <div class="preset-buttons">
                    <button class="preset-btn export-btn" onclick="exportPNG()">PNG</button>
                    <button class="preset-btn export-btn" onclick="exportCSV()">CSV</button>
                    <button class="preset-btn export-btn" onclick="exportJSON()">JSON</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global state
        let M = 32;
        let currentData = null;

        // Mathematical functions
        function gcd(a, b) {
            while (b) {
                const temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }

        function eulerPhi(n) {
            let result = n;
            let temp = n;
            for (let p = 2; p * p <= temp; p++) {
                if (temp % p === 0) {
                    while (temp % p === 0) temp /= p;
                    result -= result / p;
                }
            }
            if (temp > 1) result -= result / temp;
            return Math.round(result);
        }

        function primeFactorization(n) {
            const factors = {};
            let temp = n;
            for (let i = 2; i <= temp; i++) {
                while (temp % i === 0) {
                    factors[i] = (factors[i] || 0) + 1;
                    temp /= i;
                }
            }
            return factors;
        }

        function formatPrimeFactorization(n) {
            const factors = primeFactorization(n);
            const parts = [];
            for (const [prime, power] of Object.entries(factors)) {
                if (power === 1) parts.push(prime);
                else parts.push(`${prime}${String.fromCharCode(0x2070 + parseInt(power))}`);
            }
            return parts.join('√ó') || '1';
        }

        function isPrime(n) {
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i * i <= n; i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }

        // Calculate modular structure
        function calculate(modulus) {
            const residues = [];
            const phi = eulerPhi(modulus);
            const divisors = [];
            
            for (let d = 1; d < modulus; d++) {
                if (modulus % d === 0) divisors.push(d);
            }

            for (let r = 0; r < modulus; r++) {
                const g = gcd(r, modulus);
                const coprime = g === 1;
                const channel = modulus / g;
                const angle = -Math.PI / 2 + (2 * Math.PI * r / modulus);
                
                residues.push({
                    r,
                    gcd: g,
                    coprime,
                    channel,
                    angle,
                    x: 400 * Math.cos(angle),
                    y: 400 * Math.sin(angle)
                });
            }

            return {
                M: modulus,
                phi,
                residues,
                divisors,
                isPrime: isPrime(modulus),
                omega: Object.keys(primeFactorization(modulus)).length
            };
        }

        // Theme management
        function changeTheme() {
            const theme = document.getElementById('themeMode').value;
            if (theme === 'light') {
                document.body.classList.add('light-mode');
            } else {
                document.body.classList.remove('light-mode');
            }
        }

        // Get canvas background color
        function getCanvasBackground() {
            const bg = document.getElementById('canvasBg').value;
            const customBgGroup = document.getElementById('customBgGroup');
            
            if (bg === 'custom') {
                customBgGroup.style.display = 'block';
                return document.getElementById('customBgColor').value;
            } else {
                customBgGroup.style.display = 'none';
            }
            
            const colors = {
                'black': '#000000',
                'white': '#ffffff',
                'darkgray': '#2a2a2a',
                'lightgray': '#e0e0e0',
                'navy': '#001f3f',
                'transparent': 'transparent'
            };
            return colors[bg] || '#000000';
        }

        // Get ring color
        function getRingColor(ringIndex, totalRings) {
            const mode = document.getElementById('ringColorMode').value;
            const customRingGroup = document.getElementById('customRingGroup');
            
            if (mode === 'custom') {
                customRingGroup.style.display = 'block';
                return document.getElementById('customRingColor').value;
            } else {
                customRingGroup.style.display = 'none';
            }
            
            switch(mode) {
                case 'gold':
                    return '#ffd700';
                case 'blue':
                    return '#58a6ff';
                case 'cyan':
                    return '#00ffff';
                case 'white':
                    return '#ffffff';
                case 'gray':
                    return '#8b949e';
                case 'rainbow':
                    const hue = (ringIndex / totalRings) * 360;
                    return `hsl(${hue}, 70%, 60%)`;
                default:
                    return '#ffd700';
            }
        }

        // Apply canvas background
        function applyCanvasBackground() {
            const vizSection = document.querySelector('.viz-section');
            const bg = document.getElementById('canvasBg').value;
            
            // Remove all canvas-bg classes
            vizSection.classList.remove('canvas-bg-white', 'canvas-bg-black', 'canvas-bg-darkgray', 
                                       'canvas-bg-lightgray', 'canvas-bg-navy', 'canvas-bg-transparent');
            
            if (bg === 'custom') {
                const customColor = document.getElementById('customBgColor').value;
                vizSection.style.background = customColor;
            } else if (bg !== 'transparent') {
                vizSection.classList.add(`canvas-bg-${bg}`);
                vizSection.style.background = '';
            } else {
                vizSection.style.background = 'transparent';
            }
        }

        // Get color for multi-mod points
        function getMultiModPointColor(point, mode, totalMods) {
            const { m, r, coprime, gcd: g, modIndex } = point;
            
            switch(mode) {
                case 'coprime':
                    return coprime ? '#00ffff' : '#ff1493';
                    
                case 'bymodulus':
                    const modHue = (m / totalMods) * 360;
                    return `hsl(${modHue}, 80%, 60%)`;
                    
                case 'byring':
                    const ringHue = (modIndex / totalMods) * 360;
                    return `hsl(${ringHue}, 80%, 60%)`;
                    
                case 'byresidue':
                    const resHue = (r / m) * 360;
                    return `hsl(${resHue}, 80%, 60%)`;
                    
                case 'byinteger':
                    const intHue = ((m + r) * 37) % 360;
                    return `hsl(${intHue}, 80%, 60%)`;
                    
                case 'bygcd':
                    const gcdHue = (g * 60) % 360;
                    return `hsl(${gcdHue}, 80%, 60%)`;
                    
                case 'density':
                    const phi = eulerPhi(m);
                    const density = phi / m;
                    const densityHue = 240 - (density * 240); // Blue to red
                    return `hsl(${densityHue}, 80%, 60%)`;
                    
                case 'channel':
                    const channel = m / g;
                    const channelHue = Math.log2(channel) * 40;
                    return `hsl(${channelHue}, 80%, 60%)`;
                    
                case 'primality':
                    return isPrime(m) ? '#00ff00' : '#ff6600';
                    
                case 'omega':
                    const omega = Object.keys(primeFactorization(m)).length;
                    const omegaHue = omega * 60;
                    return `hsl(${omegaHue}, 80%, 60%)`;
                    
                case 'bigomega':
                    const factors = primeFactorization(m);
                    const bigOmega = Object.values(factors).reduce((sum, exp) => sum + exp, 0);
                    const bigOmegaHue = bigOmega * 45;
                    return `hsl(${bigOmegaHue}, 80%, 60%)`;
                    
                case 'divisors':
                    let divCount = 0;
                    for (let d = 1; d <= m; d++) {
                        if (m % d === 0) divCount++;
                    }
                    const divHue = (divCount * 20) % 360;
                    return `hsl(${divHue}, 80%, 60%)`;
                    
                case 'rainbow':
                    const rainbowHue = ((modIndex * m + r) / (totalMods * m)) * 360;
                    return `hsl(${rainbowHue}, 80%, 60%)`;
                    
                case 'alternating':
                    return ((modIndex + r) % 2 === 0) ? '#00ffff' : '#ff1493';
                    
                case 'gradient':
                    const gradHue = 200 + (modIndex / totalMods) * 160;
                    return `hsl(${gradHue}, 80%, 60%)`;
                    
                case 'heatmap':
                    const heat = modIndex / totalMods;
                    return `hsl(${(1-heat) * 240}, 100%, 50%)`;
                    
                case 'spiral':
                    const spiralHue = ((r / m) * 360 + modIndex * 30) % 360;
                    return `hsl(${spiralHue}, 80%, 60%)`;
                    
                case 'checkerboard':
                    const checker = Math.floor(r / 2) + Math.floor(modIndex / 2);
                    return (checker % 2 === 0) ? '#00ffff' : '#ff6600';
                    
                default:
                    return coprime ? '#00ffff' : '#ff1493';
            }
        }

        // Get color for multi-mod rings
        function getMultiModRingColor(m, modIndex, totalMods) {
            const mode = document.getElementById('multiModRingColor').value;
            
            switch(mode) {
                case 'gold':
                    return '#ffd700';
                    
                case 'bymodulus':
                    const modHue = (m / (totalMods * 2)) * 360;
                    return `hsl(${modHue}, 70%, 60%)`;
                    
                case 'rainbow':
                    const rainbowHue = (modIndex / totalMods) * 360;
                    return `hsl(${rainbowHue}, 70%, 60%)`;
                    
                case 'gradient':
                    const gradHue = 40 + (modIndex / totalMods) * 200; // Yellow to blue
                    return `hsl(${gradHue}, 70%, 60%)`;
                    
                case 'primality':
                    return isPrime(m) ? '#00ff00' : '#8b949e';
                    
                case 'omega':
                    const omega = Object.keys(primeFactorization(m)).length;
                    const omegaHue = omega * 60;
                    return `hsl(${omegaHue}, 70%, 60%)`;
                    
                case 'density':
                    const phi = eulerPhi(m);
                    const density = phi / m;
                    const densityHue = 120 * density; // Green scale
                    return `hsl(${densityHue}, 70%, 60%)`;
                    
                case 'divisors':
                    let divCount = 0;
                    for (let d = 1; d <= m; d++) {
                        if (m % d === 0) divCount++;
                    }
                    const divHue = (divCount * 25) % 360;
                    return `hsl(${divHue}, 70%, 60%)`;
                    
                case 'alternating':
                    return (modIndex % 2 === 0) ? '#ffd700' : '#58a6ff';
                    
                case 'pulse':
                    const pulseHue = 60 + Math.sin(modIndex * 0.5) * 30;
                    return `hsl(${pulseHue}, 70%, 60%)`;
                    
                case 'invisible':
                    return 'transparent';
                    
                default:
                    return '#ffd700';
            }
        }

        // Get color for connections
        function getConnectionColor(point, targetPoint, mode, gapSize) {
            switch(mode) {
                case 'bygap':
                    return `hsl(${(gapSize * 40) % 360}, 80%, 60%)`;
                    
                case 'bymod':
                    return `hsl(${(point.modIndex * 30) % 360}, 70%, 50%)`;
                    
                case 'byresidue':
                    return `hsl(${(point.r / point.m * 360)}, 80%, 60%)`;
                    
                case 'solid':
                    return '#58a6ff';
                    
                case 'rainbow':
                    return `hsl(${(point.r / point.m * 360)}, 80%, 60%)`;
                    
                case 'gradient':
                    const gradHue = 180 + point.modIndex * 10;
                    return `hsl(${gradHue}, 70%, 50%)`;
                    
                case 'pulse':
                    const pulseHue = 200 + Math.sin(point.modIndex * 0.3) * 60;
                    return `hsl(${pulseHue}, 80%, 60%)`;
                    
                case 'depth':
                    const depth = Math.abs(targetPoint.modIndex - point.modIndex);
                    return `hsl(${depth * 60}, 80%, 60%)`;
                    
                default:
                    return '#00ffff';
            }
        }

        // Toggle multi-modulus mode
        function toggleMultiMod() {
            const enabled = document.getElementById('enableMultiMod').checked;
            document.getElementById('multiModControls').style.display = enabled ? 'block' : 'none';
            render();
        }

        // Get color for multi-modulus point
        function getMultiModPointColor(point, startMod, endMod) {
            const mode = document.getElementById('multiModColorMode').value;
            
            switch(mode) {
                case 'coprime':
                    return point.coprime ? '#00ffff' : '#ff1493';
                    
                case 'bymodulus':
                    // Color by which modulus the point belongs to
                    const modHue = ((point.m - startMod) / (endMod - startMod)) * 360;
                    return `hsl(${modHue}, 80%, 60%)`;
                    
                case 'byresidue':
                    // Color by residue value r
                    const resHue = (point.r / point.m) * 360;
                    return `hsl(${resHue}, 80%, 60%)`;
                    
                case 'byinteger':
                    // Color by the integer value (M + r)
                    const intVal = point.m + point.r;
                    const maxInt = endMod + endMod;
                    const intHue = (intVal / maxInt) * 360;
                    return `hsl(${intHue}, 80%, 60%)`;
                    
                case 'bygcd':
                    // Color by GCD value
                    const gcdHue = (point.gcd * 60) % 360;
                    return `hsl(${gcdHue}, 80%, 60%)`;
                    
                case 'bydensity':
                    // Color by œÜ(M)/M density
                    const phi = eulerPhi(point.m);
                    const density = phi / point.m;
                    // Low density (near 0) = red, high density (near 1) = blue
                    const densityHue = density * 240; // 0¬∞ to 240¬∞ (red to blue)
                    return `hsl(${densityHue}, 80%, 60%)`;
                    
                case 'bychannel':
                    // Color by which Farey channel (M/gcd)
                    const channel = point.m / point.gcd;
                    const channelHue = (Math.log2(channel) / Math.log2(point.m)) * 360;
                    return `hsl(${channelHue}, 80%, 60%)`;
                    
                case 'byprimality':
                    // Color by whether M is prime, semiprime, or composite
                    if (isPrime(point.m)) {
                        return '#00ff00'; // Green for primes
                    } else {
                        const factors = primeFactorization(point.m);
                        const numFactors = Object.values(factors).reduce((a, b) => a + b, 0);
                        if (numFactors === 2) {
                            return '#ffff00'; // Yellow for semiprimes
                        } else {
                            return '#ff6600'; // Orange for composites
                        }
                    }
                    
                case 'byomega':
                    // Color by œâ(M) - number of distinct prime factors
                    const omega = Object.keys(primeFactorization(point.m)).length;
                    const omegaHue = (omega * 60) % 360;
                    return `hsl(${omegaHue}, 80%, 60%)`;
                    
                case 'rainbow':
                    // Rainbow by global position
                    const globalPos = point.modIndex / (endMod - startMod);
                    const rainbowHue = globalPos * 360;
                    return `hsl(${rainbowHue}, 80%, 60%)`;
                    
                default:
                    return point.coprime ? '#00ffff' : '#ff1493';
            }
        }

        // Get color for connection lines
        function getConnectionColor(p1, p2, mode, gapSize) {
            switch(mode) {
                case 'bygap':
                    return `hsl(${(gapSize * 40) % 360}, 80%, 60%)`;
                case 'bymod':
                    return `hsl(${(p1.modIndex * 30) % 360}, 70%, 50%)`;
                case 'byresidue':
                    return `hsl(${(p1.r / p1.m * 360)}, 80%, 60%)`;
                case 'solid':
                    return '#58a6ff';
                case 'rainbow':
                    return `hsl(${(p1.r / p1.m * 360)}, 80%, 60%)`;
                default:
                    return '#00ffff';
            }
        }

        // Get color for point based on mode
        function getPointColor(residue, ring, ringIndex, mode) {
            const { r, coprime, gcd: g } = residue;
            
            switch(mode) {
                case 'coprime':
                    return coprime ? '#00ffff' : '#ff1493';
                case 'byring':
                    const ringHue = (ringIndex * 40) % 360;
                    return `hsl(${ringHue}, 80%, 60%)`;
                case 'bygcd':
                    const gcdHue = (g * 60) % 360;
                    return `hsl(${gcdHue}, 80%, 60%)`;
                case 'rainbow':
                    const hue = (r / ring) * 360;
                    return `hsl(${hue}, 80%, 60%)`;
                case 'custom':
                    if (coprime) return '#00ffff';
                    return `hsl(${(ringIndex * 30) % 360}, 70%, 50%)`;
                default:
                    return coprime ? '#00ffff' : '#ff1493';
            }
        }

        // Get color for Farey line
        function getFareyLineColor(sourceRes, targetRingIndex, mode) {
            switch(mode) {
                case 'red':
                    return '#ff0000';
                case 'gold':
                    return '#ffd700';
                case 'bygcd':
                    const gcdHue = (sourceRes.gcd * 60) % 360;
                    return `hsl(${gcdHue}, 80%, 60%)`;
                case 'bydepth':
                    const depthHue = 200 + targetRingIndex * 20;
                    return `hsl(${depthHue}, 80%, 60%)`;
                case 'gradient':
                    return '#ff6b6b';
                default:
                    return '#ff0000';
            }
        }

        // Render visualization
        function render() {
            if (!currentData) return;

            const svg = document.getElementById('mainCanvas');
            svg.innerHTML = '';

            const multiModEnabled = document.getElementById('enableMultiMod').checked;
            
            if (multiModEnabled) {
                renderMultiModulus();
            } else {
                renderSingleModulus();
            }
            
            updateStatistics();
        }

        // Render single modulus mode
        function renderSingleModulus() {
            const svg = document.getElementById('mainCanvas');
            applyCanvasBackground();
            
            const zoom = parseFloat(document.getElementById('zoom').value);
            const rotation = parseFloat(document.getElementById('rotation').value);
            const ringRotation = parseFloat(document.getElementById('ringRotation').value);
            const lineThick = parseFloat(document.getElementById('lineThick').value);
            const pointSize = parseFloat(document.getElementById('pointSize').value);
            const opacity = parseFloat(document.getElementById('opacity').value) / 100;
            const showProjections = document.getElementById('showProjections').checked;
            const showChannels = document.getElementById('showChannels').checked;
            const showAllRingPoints = document.getElementById('showAllRingPoints').checked;
            const invertMode = document.getElementById('invertMode').checked;
            const pointColorMode = document.getElementById('pointColorMode').value;
            const fareyColorMode = document.getElementById('fareyColorMode').value;
            const fareyThickness = parseFloat(document.getElementById('fareyThickness').value);
            const showLabels = document.getElementById('showLabels').checked;
            const labelAllRings = document.getElementById('labelAllRings').checked;
            const labelMode = document.getElementById('labelMode').value;
            const labelSize = parseFloat(document.getElementById('labelSize').value);
            const labelDist = parseFloat(document.getElementById('labelDist').value);
            const labelCoprimeOnly = document.getElementById('labelCoprimeOnly').checked;
            const labelEveryN = parseInt(document.getElementById('labelEveryN').value);
            const labelEveryNInner = parseInt(document.getElementById('labelEveryNInner').value);
            const filterMode = document.getElementById('filterMode').value;

            const ringRotRad = (ringRotation * Math.PI) / 180;

            const mainG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            mainG.setAttribute('transform', `scale(${zoom}) rotate(${rotation})`);

            // Build ring structure
            const divisors = [];
            for (let d = 1; d <= M; d++) {
                if (M % d === 0) divisors.push(d);
            }
            
            const sortedDivisors = [...divisors].sort((a, b) => invertMode ? b - a : a - b);
            const ringIndexMap = {};
            sortedDivisors.forEach((d, idx) => {
                ringIndexMap[d] = idx;
            });

            // Draw channel rings with gold color by default
            if (showChannels) {
                sortedDivisors.forEach((d, ringIndex) => {
                    const radius = invertMode ? 400 * (M / d) : 400 * (d / M);
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', 0);
                    circle.setAttribute('cy', 0);
                    circle.setAttribute('r', radius);
                    circle.setAttribute('fill', 'none');
                    circle.setAttribute('stroke', getRingColor(ringIndex, sortedDivisors.length));
                    circle.setAttribute('stroke-width', lineThick);
                    circle.setAttribute('opacity', 0.5 * opacity);
                    mainG.appendChild(circle);
                });
            }

            // Calculate all points on all rings
            const allRingPoints = [];
            sortedDivisors.forEach((divisor, ringIndex) => {
                const radius = invertMode ? 400 * (M / divisor) : 400 * (divisor / M);
                const ringRotationAngle = ringRotRad * ringIndex;
                
                for (let k = 0; k < divisor; k++) {
                    const baseAngle = -Math.PI / 2 + (2 * Math.PI * k / divisor);
                    const angle = baseAngle + ringRotationAngle;
                    const x = radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);
                    
                    const g = gcd(k, divisor);
                    const coprime = g === 1;
                    
                    allRingPoints.push({
                        ring: divisor,
                        ringIndex,
                        r: k,
                        x, y,
                        angle,
                        baseAngle,
                        radius,
                        gcd: g,
                        coprime,
                        channel: divisor / g
                    });
                }
            });

            // Draw Farey projection lines
            if (showProjections) {
                allRingPoints.forEach(point => {
                    if (point.gcd > 1) {
                        const targetRing = point.channel;
                        const targetRingIndex = ringIndexMap[targetRing];
                        
                        if (targetRingIndex !== undefined) {
                            const targetRadius = invertMode ? 400 * (M / targetRing) : 400 * (targetRing / M);
                            const targetRotation = ringRotRad * targetRingIndex;
                            const targetAngle = point.baseAngle + targetRotation;
                            const targetX = targetRadius * Math.cos(targetAngle);
                            const targetY = targetRadius * Math.sin(targetAngle);
                            
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', point.x);
                            line.setAttribute('y1', point.y);
                            line.setAttribute('x2', targetX);
                            line.setAttribute('y2', targetY);
                            line.setAttribute('stroke', getFareyLineColor(point, targetRingIndex, fareyColorMode));
                            line.setAttribute('stroke-width', fareyThickness);
                            line.setAttribute('opacity', 0.5 * opacity);
                            mainG.appendChild(line);
                        }
                    }
                });
            }

            // Draw all points
            if (showAllRingPoints) {
                allRingPoints.forEach(point => {
                    if (point.ring === M) {
                        if (filterMode === 'coprime' && !point.coprime) return;
                        if (filterMode === 'noncoprime' && point.coprime) return;
                    }

                    const color = getPointColor(point, point.ring, point.ringIndex, pointColorMode);
                    const size = point.coprime ? pointSize : pointSize * 0.7;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', point.x);
                    circle.setAttribute('cy', point.y);
                    circle.setAttribute('r', size);
                    circle.setAttribute('fill', color);
                    circle.setAttribute('opacity', opacity);
                    mainG.appendChild(circle);
                });
            }

            // Draw labels
            if (showLabels) {
                allRingPoints.forEach((point, idx) => {
                    const isOuterRing = invertMode ? (point.ring === 1) : (point.ring === M);
                    const shouldLabelRing = isOuterRing || labelAllRings;
                    
                    if (!shouldLabelRing) return;
                    
                    const nthFilter = isOuterRing ? labelEveryN : labelEveryNInner;
                    if (point.r % nthFilter !== 0) return;
                    
                    if (labelCoprimeOnly && !point.coprime) return;
                    
                    if (isOuterRing) {
                        if (filterMode === 'coprime' && !point.coprime) return;
                        if (filterMode === 'noncoprime' && point.coprime) return;
                    }
                    
                    let labelText = '';
                    switch(labelMode) {
                        case 'residue': 
                            labelText = point.r.toString(); 
                            break;
                        case 'fraction': 
                            const reduced = gcd(point.r, point.ring);
                            const num = point.r / reduced;
                            const den = point.ring / reduced;
                            labelText = den === 1 ? num.toString() : `${num}/${den}`;
                            break;
                        case 'gcd': 
                            labelText = point.gcd.toString(); 
                            break;
                        case 'channel': 
                            labelText = point.channel.toString(); 
                            break;
                        case 'angle': 
                            labelText = Math.round(((point.baseAngle + Math.PI/2) * 180 / Math.PI) % 360) + '¬∞'; 
                            break;
                    }
                    
                    const labelRadius = point.radius + (labelDist * 20);
                    const labelX = labelRadius * Math.cos(point.angle);
                    const labelY = labelRadius * Math.sin(point.angle);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', labelX);
                    text.setAttribute('y', labelY);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('fill', '#c9d1d9');
                    text.setAttribute('font-size', labelSize);
                    text.setAttribute('opacity', opacity);
                    text.textContent = labelText;
                    mainG.appendChild(text);
                });
            }

            // Draw angle overlay if enabled
            const showAngleOverlay = document.getElementById('showAngleOverlay').checked;
            const angleFormat = document.getElementById('angleFormat').value;
            
            if (showAngleOverlay && showAllRingPoints) {
                allRingPoints.forEach((point, idx) => {
                    const isOuterRing = invertMode ? (point.ring === 1) : (point.ring === M);
                    const nthFilter = isOuterRing ? labelEveryN * 2 : labelEveryNInner * 2;
                    if (point.r % nthFilter !== 0) return;
                    
                    let angleText = '';
                    const angleRad = (2 * Math.PI * point.r) / point.ring;
                    const angleDeg = (angleRad * 180 / Math.PI) % 360;
                    
                    switch(angleFormat) {
                        case 'degrees':
                            angleText = angleDeg.toFixed(1) + '¬∞';
                            break;
                        case 'radians':
                            angleText = (angleRad / Math.PI).toFixed(3) + 'œÄ';
                            break;
                        case 'formula':
                            angleText = `2œÄ(${point.r}/${point.ring})`;
                            break;
                    }
                    
                    const textRadius = point.radius * 0.85;
                    const textX = textRadius * Math.cos(point.angle);
                    const textY = textRadius * Math.sin(point.angle);
                    
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', textX);
                    text.setAttribute('y', textY);
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('dominant-baseline', 'middle');
                    text.setAttribute('fill', '#ffd700');
                    text.setAttribute('font-size', labelSize * 0.8);
                    text.setAttribute('opacity', opacity * 0.7);
                    text.setAttribute('font-family', 'Courier New, monospace');
                    text.textContent = angleText;
                    mainG.appendChild(text);
                });
            }

            svg.appendChild(mainG);
        }

        // Render multi-modulus mode
        function renderMultiModulus() {
            const svg = document.getElementById('mainCanvas');
            applyCanvasBackground();
            
            const zoom = parseFloat(document.getElementById('zoom').value);
            const rotation = parseFloat(document.getElementById('rotation').value);
            const ringRotation = parseFloat(document.getElementById('ringRotation').value);
            const pointSize = parseFloat(document.getElementById('pointSize').value);
            const opacity = parseFloat(document.getElementById('opacity').value) / 100;
            const multiModPointColor = document.getElementById('multiModPointColor').value;
            const showRtoR = document.getElementById('showRtoRConnections').checked;
            const showGapConn = document.getElementById('showGapConnections').checked;
            const gapSize = parseInt(document.getElementById('gapSize').value);
            const connColorMode = document.getElementById('connectionColorMode').value;
            const connOpacity = parseFloat(document.getElementById('connOpacity').value) / 100;
            const connThickness = parseFloat(document.getElementById('connThickness').value);
            const ringSpacing = parseFloat(document.getElementById('ringSpacing').value);
            const filterMode = document.getElementById('filterMode').value;
            const invertMode = document.getElementById('invertMode').checked;
            const lineThick = parseFloat(document.getElementById('lineThick').value);

            const startMod = parseInt(document.getElementById('multiModStart').value) || 1;
            const endMod = parseInt(document.getElementById('multiModEnd').value) || 30;
            const totalMods = endMod - startMod + 1;

            const ringRotRad = (ringRotation * Math.PI) / 180;

            const mainG = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            mainG.setAttribute('transform', `scale(${zoom}) rotate(${rotation})`);

            // Calculate all moduli and their coprime points
            const allModuliData = [];
            for (let m = startMod; m <= endMod; m++) {
                const modIndex = m - startMod;
                const radius = invertMode ? 
                    400 - (modIndex * 400 / (endMod - startMod + 1)) * ringSpacing :
                    (modIndex + 1) * (400 / (endMod - startMod + 1)) * ringSpacing;
                
                const ringRot = ringRotRad * modIndex;
                const points = [];
                
                for (let r = 0; r < m; r++) {
                    const g = gcd(r, m);
                    const coprime = g === 1;
                    
                    // Filter
                    if (filterMode === 'coprime' && !coprime) continue;
                    if (filterMode === 'noncoprime' && coprime) continue;
                    
                    const baseAngle = -Math.PI / 2 + (2 * Math.PI * r / m);
                    const angle = baseAngle + ringRot;
                    const x = radius * Math.cos(angle);
                    const y = radius * Math.sin(angle);
                    
                    points.push({ m, r, x, y, angle, baseAngle, coprime, gcd: g, modIndex });
                }
                
                allModuliData.push({ m, radius, ringRot, points, modIndex });
            }

            // Draw r-to-r connections
            if (showRtoR) {
                for (let i = 0; i < allModuliData.length - 1; i++) {
                    const mod1 = allModuliData[i];
                    const mod2 = allModuliData[i + 1];
                    
                    mod1.points.forEach(p1 => {
                        const p2 = mod2.points.find(p => p.r === p1.r && p.coprime);
                        if (p2) {
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', p1.x);
                            line.setAttribute('y1', p1.y);
                            line.setAttribute('x2', p2.x);
                            line.setAttribute('y2', p2.y);
                            line.setAttribute('stroke', getConnectionColor(p1, p2, connColorMode, gapSize));
                            line.setAttribute('stroke-width', 0.5);
                            line.setAttribute('opacity', connOpacity);
                            mainG.appendChild(line);
                        }
                    });
                }
            }

            // Draw gap connections (r to r+2n)
            if (showGapConn) {
                allModuliData.forEach(modData => {
                    modData.points.forEach(p1 => {
                        if (!p1.coprime) return;
                        
                        const targetR = (p1.r + 2 * gapSize) % p1.m;
                        const p2 = modData.points.find(p => p.r === targetR && p.coprime);
                        
                        if (p2) {
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', p1.x);
                            line.setAttribute('y1', p1.y);
                            line.setAttribute('x2', p2.x);
                            line.setAttribute('y2', p2.y);
                            line.setAttribute('stroke', getConnectionColor(p1, p2, connColorMode, gapSize));
                            line.setAttribute('stroke-width', 0.8);
                            line.setAttribute('opacity', connOpacity);
                            mainG.appendChild(line);
                        }
                    });
                });
            }

            // Draw rings with comprehensive coloring
            allModuliData.forEach(modData => {
                const ringColor = getMultiModRingColor(modData.m, modData.modIndex, totalMods);
                if (ringColor !== 'transparent') {
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', 0);
                    circle.setAttribute('cy', 0);
                    circle.setAttribute('r', modData.radius);
                    circle.setAttribute('fill', 'none');
                    circle.setAttribute('stroke', ringColor);
                    circle.setAttribute('stroke-width', lineThick);
                    circle.setAttribute('opacity', 0.5 * opacity);
                    mainG.appendChild(circle);
                }
            });

            // Draw r-to-r connections with comprehensive coloring
            if (showRtoR) {
                for (let i = 0; i < allModuliData.length - 1; i++) {
                    const mod1 = allModuliData[i];
                    const mod2 = allModuliData[i + 1];
                    
                    mod1.points.forEach(p1 => {
                        const p2 = mod2.points.find(p => p.r === p1.r && p.coprime);
                        if (p2) {
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', p1.x);
                            line.setAttribute('y1', p1.y);
                            line.setAttribute('x2', p2.x);
                            line.setAttribute('y2', p2.y);
                            line.setAttribute('stroke', getConnectionColor(p1, p2, connColorMode, gapSize));
                            line.setAttribute('stroke-width', connThickness);
                            line.setAttribute('opacity', connOpacity);
                            mainG.appendChild(line);
                        }
                    });
                }
            }

            // Draw gap connections with comprehensive coloring
            if (showGapConn) {
                allModuliData.forEach(modData => {
                    modData.points.forEach(p1 => {
                        if (!p1.coprime) return;
                        
                        const targetR = (p1.r + 2 * gapSize) % p1.m;
                        const p2 = modData.points.find(p => p.r === targetR && p.coprime);
                        
                        if (p2) {
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', p1.x);
                            line.setAttribute('y1', p1.y);
                            line.setAttribute('x2', p2.x);
                            line.setAttribute('y2', p2.y);
                            line.setAttribute('stroke', getConnectionColor(p1, p2, connColorMode, gapSize));
                            line.setAttribute('stroke-width', connThickness);
                            line.setAttribute('opacity', connOpacity);
                            mainG.appendChild(line);
                        }
                    });
                });
            }

            // Draw all points with comprehensive coloring
            allModuliData.forEach(modData => {
                modData.points.forEach(point => {
                    const color = getMultiModPointColor(point, multiModPointColor, totalMods);
                    const size = point.coprime ? pointSize : pointSize * 0.7;
                    
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('cx', point.x);
                    circle.setAttribute('cy', point.y);
                    circle.setAttribute('r', size);
                    circle.setAttribute('fill', color);
                    circle.setAttribute('opacity', opacity);
                    mainG.appendChild(circle);
                });
            });

            svg.appendChild(mainG);
        }
        // Update analysis panel
        function updateAnalysis() {
            const showAnalysis = document.getElementById('showAnalysis').checked;
            const analysisPanel = document.getElementById('analysisPanel');
            
            if (!showAnalysis) {
                analysisPanel.style.display = 'none';
                return;
            }
            
            analysisPanel.style.display = 'block';
            
            if (!currentData) return;
            
            // Update main analysis values
            document.getElementById('analysisMod').textContent = M;
            document.getElementById('analysisFactorization').textContent = formatPrimeFactorization(M);
            document.getElementById('analysisCoprimeCount').textContent = currentData.phi;
            document.getElementById('analysisReducibleCount').textContent = M - currentData.phi;
            
            const reduciblePercent = ((M - currentData.phi) / M * 100).toFixed(1);
            document.getElementById('analysisRatio').textContent = reduciblePercent + '% reducible';
            
            // Build Farey channels list
            const fareyList = document.getElementById('fareyChannelsList');
            fareyList.innerHTML = '';
            
            // Get all divisors except M itself
            const divisors = [];
            for (let d = 1; d < M; d++) {
                if (M % d === 0) divisors.push(d);
            }
            divisors.sort((a, b) => b - a); // Sort descending
            
            divisors.forEach(divisor => {
                const multiplicity = M / divisor;
                const residueCount = currentData.residues.filter(r => r.channel === divisor).length;
                
                const line = document.createElement('div');
                line.style.margin = '4px 0';
                line.innerHTML = `M' = ${divisor}: ${residueCount} residues (d = ${multiplicity})`;
                fareyList.appendChild(line);
            });
        }

        // Update channel information display
        function updateChannelInfo() {
            const showInfo = document.getElementById('showChannelInfo').checked;
            const channelInfo = document.getElementById('channelInfo');
            
            if (!showInfo) {
                channelInfo.style.display = 'none';
                return;
            }
            
            channelInfo.style.display = 'block';
            
            if (!currentData) return;
            
            const channelList = document.getElementById('channelList');
            channelList.innerHTML = '';
            
            // Get all divisors
            const divisors = [];
            for (let d = 1; d <= M; d++) {
                if (M % d === 0) divisors.push(d);
            }
            
            divisors.sort((a, b) => a - b);
            
            // For each divisor (ring), show its angles
            divisors.forEach(divisor => {
                const channelDiv = document.createElement('div');
                channelDiv.className = 'channel-item';
                
                // Header with M' and ratio
                const header = document.createElement('div');
                header.className = 'channel-header';
                header.textContent = `Ring M' = ${divisor}`;
                channelDiv.appendChild(header);
                
                // Show ratio M'/M
                const ratio = document.createElement('div');
                ratio.className = 'channel-ratio';
                const ratioValue = (divisor / M).toFixed(4);
                ratio.textContent = `Ratio: ${divisor}/${M} = ${ratioValue}`;
                channelDiv.appendChild(ratio);
                
                // Angular spacing formula
                const formula = document.createElement('div');
                formula.className = 'channel-formula';
                const angularSpacing = (360 / divisor).toFixed(2);
                formula.textContent = `Angular spacing: 360¬∞/${divisor} = ${angularSpacing}¬∞`;
                channelDiv.appendChild(formula);
                
                // Show angles for first few points (or all if small)
                const numPointsToShow = divisor <= 12 ? divisor : 12;
                const angleListDiv = document.createElement('div');
                angleListDiv.className = 'angle-list';
                
                for (let r = 0; r < numPointsToShow; r++) {
                    const angleChip = document.createElement('div');
                    angleChip.className = 'angle-chip';
                    
                    // Calculate angle using 2œÄr/M' formula
                    const angleRad = (2 * Math.PI * r) / divisor;
                    const angleDeg = (angleRad * 180 / Math.PI).toFixed(1);
                    
                    angleChip.textContent = `r=${r}: ${angleDeg}¬∞`;
                    angleListDiv.appendChild(angleChip);
                }
                
                if (divisor > 12) {
                    const moreChip = document.createElement('div');
                    moreChip.className = 'angle-chip';
                    moreChip.style.background = 'transparent';
                    moreChip.style.border = 'none';
                    moreChip.textContent = `... ${divisor - 12} more`;
                    angleListDiv.appendChild(moreChip);
                }
                
                channelDiv.appendChild(angleListDiv);
                
                // Number of points on this ring
                const pointCount = document.createElement('div');
                pointCount.className = 'channel-formula';
                pointCount.style.marginTop = '8px';
                pointCount.textContent = `Total points: ${divisor}`;
                channelDiv.appendChild(pointCount);
                
                channelList.appendChild(channelDiv);
            });
        }

        // Update statistics display
        function updateStatistics() {
            if (!currentData) return;
            
            document.getElementById('statM').textContent = currentData.M;
            document.getElementById('statPhi').textContent = currentData.phi;
            document.getElementById('statCoprime').textContent = currentData.residues.filter(r => r.coprime).length;
            document.getElementById('statNonCoprime').textContent = currentData.residues.filter(r => !r.coprime).length;
            document.getElementById('statChannels').textContent = currentData.divisors.length;
            document.getElementById('statDensity').textContent = ((currentData.phi / currentData.M) * 100).toFixed(1) + '%';
            document.getElementById('statClass').textContent = currentData.isPrime ? 'Prime' : 'Composite';
            document.getElementById('omegaBadge').textContent = currentData.isPrime ? 'Prime' : `œâ(M)=${currentData.omega}`;
        }

        // Set modulus
        function setModulus(value) {
            M = value;
            document.getElementById('modulusSlider').value = value;
            document.getElementById('modulusInput').value = value;
            document.getElementById('modulusValue').textContent = value;
            document.getElementById('currentM').textContent = value;
            document.getElementById('primeFactorization').textContent = formatPrimeFactorization(value);
            
            currentData = calculate(M);
            render();
            updateChannelInfo();
            updateAnalysis();
        }

        // Animation and Recording state
        let animationState = {
            interval: null,
            currentValue: 2,
            rotationValue: 0,
            recording: false,
            frames: [],
            frameCount: 0
        };

        // Toggle recording options visibility
        function toggleRecordingOptions() {
            const enabled = document.getElementById('recordAnimation').checked;
            document.getElementById('recordingOptions').style.display = enabled ? 'block' : 'none';
        }

        // Capture current frame
        async function captureFrame() {
            const resolution = parseInt(document.getElementById('recordResolution').value);
            const withLegend = document.getElementById('recordWithLegend').checked;
            const withTitle = document.getElementById('recordWithTitle').checked;
            const multiModEnabled = document.getElementById('enableMultiMod').checked;
            
            return new Promise((resolve) => {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                if (withTitle || withLegend) {
                    canvas.width = resolution;
                    canvas.height = resolution;
                } else {
                    canvas.width = resolution;
                    canvas.height = Math.round(resolution * 1.1);
                }
                
                const canvasBgColor = getCanvasBackground();
                ctx.fillStyle = canvasBgColor;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const svg = document.getElementById('mainCanvas');
                const serializer = new XMLSerializer();
                const svgStr = serializer.serializeToString(svg);
                
                const img = new Image();
                const blob = new Blob([svgStr], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                
                img.onload = function() {
                    if (!withTitle && !withLegend) {
                        const vizSize = resolution * 0.85;
                        const vizX = (canvas.width - vizSize) / 2;
                        const vizY = resolution * 0.1;
                        
                        ctx.drawImage(img, vizX, vizY, vizSize, vizSize);
                        
                        ctx.font = `${resolution * 0.04}px Arial`;
                        ctx.fillStyle = '#79c0ff';
                        ctx.textAlign = 'center';
                        if (multiModEnabled) {
                            const startMod = parseInt(document.getElementById('multiModStart').value) || 1;
                            const endMod = parseInt(document.getElementById('multiModEnd').value) || 30;
                            ctx.fillText(`Multi-Modulus: M = ${startMod} to ${endMod}`, canvas.width / 2, resolution * 0.05);
                        } else {
                            ctx.fillText(`M = ${M}`, canvas.width / 2, resolution * 0.05);
                        }
                    } else {
                        // Use full export layout (simplified version)
                        const leftPanel = resolution * 0.7;
                        const padding = resolution * 0.03;
                        
                        if (withTitle) {
                            ctx.font = `bold ${resolution * 0.025}px Arial`;
                            ctx.fillStyle = canvasBgColor === '#ffffff' ? '#1f2328' : '#ffffff';
                            ctx.textAlign = 'center';
                            ctx.fillText(multiModEnabled ? 'Multi-Modulus Animation' : 'Modular Animation', canvas.width / 2, padding * 1.5);
                            
                            ctx.font = `${resolution * 0.012}px Arial`;
                            ctx.fillStyle = canvasBgColor === '#ffffff' ? '#656d76' : '#8b949e';
                            ctx.fillText(`Frame ${animationState.frameCount}`, canvas.width / 2, padding * 2.3);
                        }
                        
                        const titleHeight = withTitle ? padding * 3 : padding;
                        const vizSize = leftPanel - padding * 2;
                        const vizX = padding;
                        const vizY = titleHeight + (canvas.height - titleHeight - vizSize) / 2;
                        ctx.drawImage(img, vizX, vizY, vizSize, vizSize);
                        
                        ctx.font = `${resolution * 0.02}px Arial`;
                        ctx.fillStyle = '#79c0ff';
                        ctx.textAlign = 'center';
                        if (multiModEnabled) {
                            const startMod = parseInt(document.getElementById('multiModStart').value) || 1;
                            const endMod = parseInt(document.getElementById('multiModEnd').value) || 30;
                            ctx.fillText(`Moduli: M = ${startMod} to ${endMod}`, vizX + vizSize / 2, vizY - padding * 0.5);
                        } else {
                            ctx.fillText(`M = ${M}`, vizX + vizSize / 2, vizY - padding * 0.5);
                        }
                    }
                    
                    URL.revokeObjectURL(url);
                    canvas.toBlob(blob => {
                        resolve(blob);
                    });
                };
                
                img.src = url;
            });
        }

        // Animation
        let animationState = {
        function startAnimation() {
            if (animationState.interval) {
                stopAnimation();
            }
            
            const mode = document.getElementById('animMode').value;
            const baseSpeed = parseInt(document.getElementById('animSpeed').value);
            const multiplier = parseFloat(document.getElementById('speedMultiplier').value);
            const actualSpeed = baseSpeed / multiplier;
            const loop = document.getElementById('loopAnim').checked;
            const startVal = parseInt(document.getElementById('animStart').value) || 2;
            const endVal = parseInt(document.getElementById('animEnd').value) || 200;
            const shouldRecord = document.getElementById('recordAnimation').checked;
            const maxFrames = parseInt(document.getElementById('maxFrames').value) || 100;
            
            // Initialize recording if enabled
            if (shouldRecord) {
                animationState.recording = true;
                animationState.frames = [];
                animationState.frameCount = 0;
                document.getElementById('recordingStatus').textContent = 'Recording... Frame 0';
                document.getElementById('exportFramesBtn').disabled = true;
                document.getElementById('exportGifBtn').disabled = true;
            }
            
            // Initialize based on mode
            if (mode === 'increment' || mode === 'decrement') {
                animationState.currentValue = mode === 'increment' ? startVal : endVal;
            } else if (mode === 'rotate' || mode === 'rotateGlobal') {
                animationState.rotationValue = 0;
            }
            
            animationState.interval = setInterval(async () => {
                switch(mode) {
                    case 'increment':
                        animationState.currentValue++;
                        if (animationState.currentValue > endVal) {
                            if (loop && (!shouldRecord || animationState.frameCount < maxFrames)) {
                                animationState.currentValue = startVal;
                            } else {
                                stopAnimation();
                                return;
                            }
                        }
                        setModulus(animationState.currentValue);
                        break;
                        
                    case 'decrement':
                        animationState.currentValue--;
                        if (animationState.currentValue < startVal) {
                            if (loop && (!shouldRecord || animationState.frameCount < maxFrames)) {
                                animationState.currentValue = endVal;
                            } else {
                                stopAnimation();
                                return;
                            }
                        }
                        setModulus(animationState.currentValue);
                        break;
                        
                    case 'rotate':
                        animationState.rotationValue += 2 * multiplier;
                        if (animationState.rotationValue >= 720) {
                            if (loop && (!shouldRecord || animationState.frameCount < maxFrames)) {
                                animationState.rotationValue = 0;
                            } else {
                                stopAnimation();
                                return;
                            }
                        }
                        document.getElementById('ringRotation').value = animationState.rotationValue;
                        document.getElementById('ringRotValue').textContent = animationState.rotationValue.toFixed(1);
                        document.getElementById('ringRotInput').value = Math.round(animationState.rotationValue);
                        render();
                        break;
                        
                    case 'rotateGlobal':
                        animationState.rotationValue += 2 * multiplier;
                        if (animationState.rotationValue >= 360) {
                            if (loop && (!shouldRecord || animationState.frameCount < maxFrames)) {
                                animationState.rotationValue = 0;
                            } else {
                                stopAnimation();
                                return;
                            }
                        }
                        document.getElementById('rotation').value = animationState.rotationValue;
                        document.getElementById('rotationValue').textContent = Math.round(animationState.rotationValue);
                        render();
                        break;
                }
                
                // Capture frame if recording
                if (shouldRecord && animationState.frameCount < maxFrames) {
                    const frameBlob = await captureFrame();
                    animationState.frames.push(frameBlob);
                    animationState.frameCount++;
                    document.getElementById('recordingStatus').textContent = `Recording... Frame ${animationState.frameCount}`;
                    
                    if (animationState.frameCount >= maxFrames) {
                        stopAnimation();
                    }
                }
            }, actualSpeed);
        }

        function stopAnimation() {
            if (animationState.interval) {
                clearInterval(animationState.interval);
                animationState.interval = null;
            }
            
            if (animationState.recording) {
                animationState.recording = false;
                document.getElementById('recordingStatus').textContent = `Recording complete! ${animationState.frameCount} frames captured.`;
                document.getElementById('exportFramesBtn').disabled = false;
                document.getElementById('exportGifBtn').disabled = false;
            }
        }

        // Export recorded frames as ZIP
        async function exportRecordedFrames() {
            if (animationState.frames.length === 0) {
                alert('No frames to export!');
                return;
            }
            
            document.getElementById('recordingStatus').textContent = 'Creating ZIP file...';
            
            // Use JSZip library (we'll include it inline)
            const zip = await createZipFromFrames(animationState.frames);
            const blob = await zip.generateAsync({ type: 'blob' });
            
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `animation-${animationState.frameCount}-frames-${Date.now()}.zip`;
            a.click();
            
            document.getElementById('recordingStatus').textContent = `ZIP exported with ${animationState.frameCount} frames!`;
        }

        // Create ZIP from frames
        async function createZipFromFrames(frames) {
            // Minimal ZIP implementation
            const files = [];
            
            for (let i = 0; i < frames.length; i++) {
                const arrayBuffer = await frames[i].arrayBuffer();
                files.push({
                    name: `frame-${String(i).padStart(5, '0')}.png`,
                    data: new Uint8Array(arrayBuffer)
                });
            }
            
            // Create ZIP structure
            const zipData = [];
            const centralDirectory = [];
            let offset = 0;
            
            for (const file of files) {
                const fileNameBytes = new TextEncoder().encode(file.name);
                
                // Local file header
                const localHeader = new Uint8Array(30 + fileNameBytes.length);
                new DataView(localHeader.buffer).setUint32(0, 0x04034b50, true); // signature
                new DataView(localHeader.buffer).setUint16(4, 20, true); // version
                new DataView(localHeader.buffer).setUint16(8, 0, true); // compression (stored)
                new DataView(localHeader.buffer).setUint32(18, file.data.length, true); // uncompressed size
                new DataView(localHeader.buffer).setUint32(22, file.data.length, true); // compressed size
                new DataView(localHeader.buffer).setUint16(26, fileNameBytes.length, true); // filename length
                localHeader.set(fileNameBytes, 30);
                
                zipData.push(localHeader);
                zipData.push(file.data);
                
                // Central directory entry
                const cdEntry = new Uint8Array(46 + fileNameBytes.length);
                new DataView(cdEntry.buffer).setUint32(0, 0x02014b50, true); // signature
                new DataView(cdEntry.buffer).setUint16(4, 20, true); // version made by
                new DataView(cdEntry.buffer).setUint16(6, 20, true); // version needed
                new DataView(cdEntry.buffer).setUint16(10, 0, true); // compression
                new DataView(cdEntry.buffer).setUint32(20, file.data.length, true); // uncompressed size
                new DataView(cdEntry.buffer).setUint32(24, file.data.length, true); // compressed size
                new DataView(cdEntry.buffer).setUint16(28, fileNameBytes.length, true); // filename length
                new DataView(cdEntry.buffer).setUint32(42, offset, true); // local header offset
                cdEntry.set(fileNameBytes, 46);
                
                centralDirectory.push(cdEntry);
                offset += localHeader.length + file.data.length;
            }
            
            // Combine all parts
            const cdStart = offset;
            zipData.push(...centralDirectory);
            const cdSize = centralDirectory.reduce((sum, entry) => sum + entry.length, 0);
            
            // End of central directory
            const eocd = new Uint8Array(22);
            new DataView(eocd.buffer).setUint32(0, 0x06054b50, true); // signature
            new DataView(eocd.buffer).setUint16(8, files.length, true); // total entries
            new DataView(eocd.buffer).setUint16(10, files.length, true); // total entries
            new DataView(eocd.buffer).setUint32(12, cdSize, true); // central directory size
            new DataView(eocd.buffer).setUint32(16, cdStart, true); // central directory offset
            zipData.push(eocd);
            
            // Combine all chunks
            const totalLength = zipData.reduce((sum, chunk) => sum + chunk.length, 0);
            const result = new Uint8Array(totalLength);
            let pos = 0;
            for (const chunk of zipData) {
                result.set(chunk, pos);
                pos += chunk.length;
            }
            
            return {
                generateAsync: async () => new Blob([result], { type: 'application/zip' })
            };
        }

        // Export as GIF using simple GIF encoding
        async function exportAsGIF() {
            if (animationState.frames.length === 0) {
                alert('No frames to export!');
                return;
            }
            
            document.getElementById('recordingStatus').textContent = 'Creating GIF... This may take a moment.';
            
            try {
                // Convert frames to canvas images
                const frameDelay = parseInt(document.getElementById('animSpeed').value);
                const canvases = [];
                
                for (let i = 0; i < animationState.frames.length; i++) {
                    const img = await blobToImage(animationState.frames[i]);
                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);
                    canvases.push(canvas);
                    
                    if (i % 10 === 0) {
                        document.getElementById('recordingStatus').textContent = `Processing frame ${i + 1}/${animationState.frames.length}...`;
                    }
                }
                
                // Simple GIF encoding (basic implementation)
                document.getElementById('recordingStatus').textContent = 'Encoding GIF...';
                const gifBlob = await encodeGIF(canvases, frameDelay);
                
                const a = document.createElement('a');
                a.href = URL.createObjectURL(gifBlob);
                a.download = `animation-${animationState.frameCount}-frames-${Date.now()}.gif`;
                a.click();
                
                document.getElementById('recordingStatus').textContent = `GIF exported with ${animationState.frameCount} frames!`;
            } catch (error) {
                document.getElementById('recordingStatus').textContent = `Error creating GIF: ${error.message}. Try exporting as ZIP instead.`;
                console.error(error);
            }
        }

        // Helper: Convert blob to image
        function blobToImage(blob) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.onload = () => resolve(img);
                img.onerror = reject;
                img.src = URL.createObjectURL(blob);
            });
        }

        // Simple GIF encoder (basic implementation)
        async function encodeGIF(canvases, delay) {
            // This is a simplified GIF encoder
            // For production, you'd want to use a library like gif.js
            
            const width = canvases[0].width;
            const height = canvases[0].height;
            
            // GIF Header
            const header = new Uint8Array([
                0x47, 0x49, 0x46, 0x38, 0x39, 0x61, // GIF89a
                width & 0xff, width >> 8, // width
                height & 0xff, height >> 8, // height
                0xf7, 0x00, 0x00 // global color table flag, background, aspect ratio
            ]);
            
            // For simplicity, we'll create a WebM video instead which browsers support better
            // This requires MediaRecorder API
            alert('GIF export requires additional processing. Frames have been saved. Please use the ZIP export and convert to GIF using external tools like ffmpeg or online converters.');
            
            // Return empty blob as placeholder
            return new Blob([], { type: 'image/gif' });
        }

        // Export functions
        function exportPNG() {
            const resolution = parseInt(document.getElementById('exportRes').value);
            const withLegend = document.getElementById('exportWithLegend').checked;
            const withTitle = document.getElementById('exportWithTitle').checked;
            const multiModEnabled = document.getElementById('enableMultiMod').checked;
            
            // Create canvas for export
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Set canvas size based on whether we're including legend
            if (withTitle || withLegend) {
                canvas.width = resolution;
                canvas.height = resolution;
            } else {
                // Just the visualization and M number
                canvas.width = resolution;
                canvas.height = Math.round(resolution * 1.1);
            }
            
            // Fill background based on canvas background setting
            const canvasBgColor = getCanvasBackground();
            ctx.fillStyle = canvasBgColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Get current SVG
            const svg = document.getElementById('mainCanvas');
            const serializer = new XMLSerializer();
            const svgStr = serializer.serializeToString(svg);
            
            const img = new Image();
            const blob = new Blob([svgStr], { type: 'image/svg+xml' });
            const url = URL.createObjectURL(blob);
            
            img.onload = function() {
                if (!withTitle && !withLegend) {
                    // Simple export: just label and visualization
                    const vizSize = resolution * 0.85;
                    const vizX = (canvas.width - vizSize) / 2;
                    const vizY = resolution * 0.1;
                    
                    ctx.drawImage(img, vizX, vizY, vizSize, vizSize);
                    
                    // Add label at top
                    ctx.font = `${resolution * 0.04}px Arial`;
                    ctx.fillStyle = '#79c0ff';
                    ctx.textAlign = 'center';
                    if (multiModEnabled) {
                        const startMod = parseInt(document.getElementById('multiModStart').value) || 1;
                        const endMod = parseInt(document.getElementById('multiModEnd').value) || 30;
                        ctx.fillText(`Multi-Modulus: M = ${startMod} to ${endMod}`, canvas.width / 2, resolution * 0.05);
                    } else {
                        ctx.fillText(`M = ${M}`, canvas.width / 2, resolution * 0.05);
                    }
                    
                } else {
                    // Full professional export
                    const leftPanel = resolution * 0.65;
                    const rightPanel = resolution * 0.35;
                    const padding = resolution * 0.03;
                    
                    // TITLE at top
                    if (withTitle) {
                        ctx.font = `bold ${resolution * 0.025}px Arial`;
                        ctx.fillStyle = canvasBgColor === '#ffffff' ? '#1f2328' : '#ffffff';
                        ctx.textAlign = 'center';
                        
                        if (multiModEnabled) {
                            ctx.fillText('Multi-Modulus Projection Explorer', canvas.width / 2, padding * 1.5);
                        } else {
                            ctx.fillText('Modular Reduction Projection Explorer', canvas.width / 2, padding * 1.5);
                        }
                        
                        // Timestamp
                        ctx.font = `${resolution * 0.012}px Arial`;
                        ctx.fillStyle = canvasBgColor === '#ffffff' ? '#656d76' : '#8b949e';
                        const now = new Date();
                        ctx.fillText(now.toLocaleString(), canvas.width / 2, padding * 2.3);
                    }
                    
                    const titleHeight = withTitle ? padding * 3 : padding;
                    
                    // VISUALIZATION (left side, centered)
                    const vizSize = leftPanel - padding * 2;
                    const vizX = padding;
                    const vizY = titleHeight + (canvas.height - titleHeight - vizSize) / 2;
                    ctx.drawImage(img, vizX, vizY, vizSize, vizSize);
                    
                    // Add label on visualization
                    ctx.font = `${resolution * 0.02}px Arial`;
                    ctx.fillStyle = '#79c0ff';
                    ctx.textAlign = 'center';
                    if (multiModEnabled) {
                        const startMod = parseInt(document.getElementById('multiModStart').value) || 1;
                        const endMod = parseInt(document.getElementById('multiModEnd').value) || 30;
                        ctx.fillText(`Moduli: M = ${startMod} to ${endMod}`, vizX + vizSize / 2, vizY - padding * 0.5);
                    } else {
                        ctx.fillText(`Modulus M = ${M}`, vizX + vizSize / 2, vizY - padding * 0.5);
                    }
                    
                    // RIGHT PANEL - Legend and Stats
                    if (withLegend) {
                        const rightX = leftPanel + padding;
                        let currentY = titleHeight + padding;
                        const textColor = canvasBgColor === '#ffffff' ? '#1f2328' : '#c9d1d9';
                        const headingColor = canvasBgColor === '#ffffff' ? '#0969da' : '#79c0ff';
                        const mutedColor = canvasBgColor === '#ffffff' ? '#656d76' : '#8b949e';
                        
                        if (multiModEnabled) {
                            // MULTI-MODULUS MODE CONFIGURATION
                            const startMod = parseInt(document.getElementById('multiModStart').value) || 1;
                            const endMod = parseInt(document.getElementById('multiModEnd').value) || 30;
                            const showRtoR = document.getElementById('showRtoRConnections').checked;
                            const showGapConn = document.getElementById('showGapConnections').checked;
                            const gapSize = parseInt(document.getElementById('gapSize').value);
                            const connColorMode = document.getElementById('connectionColorMode').value;
                            const ringSpacing = parseFloat(document.getElementById('ringSpacing').value);
                            const invertMode = document.getElementById('invertMode').checked;
                            
                            ctx.font = `bold ${resolution * 0.018}px Arial`;
                            ctx.fillStyle = headingColor;
                            ctx.textAlign = 'left';
                            ctx.fillText('CONFIGURATION', rightX, currentY);
                            currentY += padding * 0.8;
                            
                            ctx.strokeStyle = canvasBgColor === '#ffffff' ? '#d0d7de' : '#30363d';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(rightX, currentY);
                            ctx.lineTo(rightX + rightPanel - padding * 2, currentY);
                            ctx.stroke();
                            currentY += padding * 0.8;
                            
                            ctx.font = `${resolution * 0.013}px Arial`;
                            ctx.fillStyle = textColor;
                            
                            ctx.fillText(`Modulus Range: ${startMod} to ${endMod}`, rightX, currentY);
                            currentY += padding * 0.6;
                            ctx.fillText(`Total Moduli: ${endMod - startMod + 1}`, rightX, currentY);
                            currentY += padding * 0.6;
                            
                            const multiModColorMode = document.getElementById('multiModColorMode').value;
                            ctx.fillText(`Point Coloring: ${multiModColorMode}`, rightX, currentY);
                            currentY += padding * 0.6;
                            
                            ctx.fillText(`Ring Spacing: ${ringSpacing.toFixed(1)}√ó`, rightX, currentY);
                            currentY += padding * 0.6;
                            ctx.fillText(`Invert Mode: ${invertMode ? 'Enabled' : 'Disabled'}`, rightX, currentY);
                            currentY += padding * 1.2;
                            
                            // CONNECTION SETTINGS
                            ctx.font = `bold ${resolution * 0.018}px Arial`;
                            ctx.fillStyle = headingColor;
                            ctx.fillText('CONNECTIONS', rightX, currentY);
                            currentY += padding * 0.8;
                            
                            ctx.strokeStyle = canvasBgColor === '#ffffff' ? '#d0d7de' : '#30363d';
                            ctx.beginPath();
                            ctx.moveTo(rightX, currentY);
                            ctx.lineTo(rightX + rightPanel - padding * 2, currentY);
                            ctx.stroke();
                            currentY += padding * 0.8;
                            
                            ctx.font = `${resolution * 0.013}px Arial`;
                            ctx.fillStyle = textColor;
                            
                            ctx.fillText(`r-to-r Connections: ${showRtoR ? 'Enabled' : 'Disabled'}`, rightX, currentY);
                            currentY += padding * 0.6;
                            ctx.fillText(`Gap Connections: ${showGapConn ? 'Enabled' : 'Disabled'}`, rightX, currentY);
                            currentY += padding * 0.6;
                            if (showGapConn) {
                                ctx.fillText(`Gap Size (2n): 2√ó${gapSize} = ${2*gapSize}`, rightX, currentY);
                                currentY += padding * 0.6;
                            }
                            ctx.fillText(`Connection Color: ${connColorMode}`, rightX, currentY);
                            currentY += padding * 1.2;
                            
                            // ANALYSIS
                            ctx.font = `bold ${resolution * 0.018}px Arial`;
                            ctx.fillStyle = headingColor;
                            ctx.fillText('ANALYSIS', rightX, currentY);
                            currentY += padding * 0.8;
                            
                            ctx.strokeStyle = canvasBgColor === '#ffffff' ? '#d0d7de' : '#30363d';
                            ctx.beginPath();
                            ctx.moveTo(rightX, currentY);
                            ctx.lineTo(rightX + rightPanel - padding * 2, currentY);
                            ctx.stroke();
                            currentY += padding * 0.8;
                            
                            ctx.font = `${resolution * 0.012}px Arial`;
                            ctx.fillStyle = textColor;
                            
                            // Calculate total coprime count across all moduli
                            let totalCoprime = 0;
                            let totalPoints = 0;
                            for (let m = startMod; m <= endMod; m++) {
                                totalPoints += m;
                                totalCoprime += eulerPhi(m);
                            }
                            
                            ctx.fillText(`Total Points: ${totalPoints}`, rightX, currentY);
                            currentY += padding * 0.6;
                            ctx.fillText(`Coprime Points: ${totalCoprime}`, rightX, currentY);
                            currentY += padding * 0.6;
                            const avgDensity = ((totalCoprime / totalPoints) * 100).toFixed(1);
                            ctx.fillText(`Average Density: ${avgDensity}%`, rightX, currentY);
                            currentY += padding * 1.2;
                            
                            // COLOR KEY
                            ctx.font = `bold ${resolution * 0.018}px Arial`;
                            ctx.fillStyle = headingColor;
                            ctx.fillText('COLOR KEY', rightX, currentY);
                            currentY += padding * 0.8;
                            
                            ctx.strokeStyle = canvasBgColor === '#ffffff' ? '#d0d7de' : '#30363d';
                            ctx.beginPath();
                            ctx.moveTo(rightX, currentY);
                            ctx.lineTo(rightX + rightPanel - padding * 2, currentY);
                            ctx.stroke();
                            currentY += padding * 0.8;
                            
                            const swatchSize = resolution * 0.015;
                            const swatchGap = resolution * 0.025;
                            
                            ctx.font = `${resolution * 0.012}px Arial`;
                            ctx.fillStyle = textColor;
                            
                            // Cyan
                            ctx.fillStyle = '#00ffff';
                            ctx.fillRect(rightX, currentY - swatchSize * 0.7, swatchSize, swatchSize);
                            ctx.fillStyle = textColor;
                            ctx.fillText('Cyan = Coprime (gcd=1)', rightX + swatchGap, currentY);
                            currentY += padding * 0.8;
                            
                            // Red
                            ctx.fillStyle = '#ff1493';
                            ctx.fillRect(rightX, currentY - swatchSize * 0.7, swatchSize, swatchSize);
                            ctx.fillStyle = textColor;
                            ctx.fillText('Red = Non-coprime (gcd>1)', rightX + swatchGap, currentY);
                            currentY += padding * 0.8;
                            
                            // Rings
                            ctx.fillStyle = '#ffd700';
                            ctx.fillRect(rightX, currentY - swatchSize * 0.7, swatchSize, swatchSize);
                            ctx.fillStyle = textColor;
                            ctx.fillText('Gold = Modulus Rings', rightX + swatchGap, currentY);
                            currentY += padding * 1.2;
                            
                            // KEY RESULT
                            ctx.font = `bold ${resolution * 0.018}px Arial`;
                            ctx.fillStyle = headingColor;
                            ctx.fillText('KEY RESULT', rightX, currentY);
                            currentY += padding * 0.8;
                            
                            ctx.strokeStyle = canvasBgColor === '#ffffff' ? '#d0d7de' : '#30363d';
                            ctx.beginPath();
                            ctx.moveTo(rightX, currentY);
                            ctx.lineTo(rightX + rightPanel - padding * 2, currentY);
                            ctx.stroke();
                            currentY += padding * 0.8;
                            
                            ctx.font = `${resolution * 0.011}px Arial`;
                            ctx.fillStyle = textColor;
                            const maxWidth = rightPanel - padding * 3;
                            
                            if (showRtoR) {
                                wrapText(ctx, 'r-to-r connections show how the same residue value appears across consecutive moduli, revealing structural patterns in coprime distributions.', 
                                        rightX, currentY, maxWidth, padding * 0.5);
                                currentY += padding * 2.0;
                            }
                            
                            if (showGapConn) {
                                wrapText(ctx, `Gap connections (r to r+${2*gapSize}) within each ring reveal prime constellation patterns like twin, cousin, and sexy primes across all moduli.`, 
                                        rightX, currentY, maxWidth, padding * 0.5);
                                currentY += padding * 2.0;
                            }
                            
                        } else {
                            // SINGLE MODULUS MODE CONFIGURATION
                            ctx.font = `bold ${resolution * 0.018}px Arial`;
                            ctx.fillStyle = headingColor;
                            ctx.textAlign = 'left';
                            ctx.fillText('CONFIGURATION', rightX, currentY);
                            currentY += padding * 0.8;
                            
                            ctx.strokeStyle = canvasBgColor === '#ffffff' ? '#d0d7de' : '#30363d';
                            ctx.lineWidth = 2;
                            ctx.beginPath();
                            ctx.moveTo(rightX, currentY);
                            ctx.lineTo(rightX + rightPanel - padding * 2, currentY);
                            ctx.stroke();
                            currentY += padding * 0.8;
                            
                            ctx.font = `${resolution * 0.013}px Arial`;
                            ctx.fillStyle = textColor;
                            
                            ctx.fillText(`Modulus M = ${M}`, rightX, currentY);
                            currentY += padding * 0.6;
                            ctx.fillText(`Prime Factorization: ${formatPrimeFactorization(M)}`, rightX, currentY);
                            currentY += padding * 0.6;
                            
                            const pointColorMode = document.getElementById('pointColorMode').value;
                            ctx.fillText(`Point Color: ${pointColorMode}`, rightX, currentY);
                            currentY += padding * 0.6;
                            
                            const invertMode = document.getElementById('invertMode').checked;
                            ctx.fillText(`Invert Mode: ${invertMode ? 'Enabled' : 'Disabled'}`, rightX, currentY);
                            currentY += padding * 1.2;
                            
                            // STATISTICS section
                            ctx.font = `bold ${resolution * 0.018}px Arial`;
                            ctx.fillStyle = headingColor;
                            ctx.fillText('STATISTICS', rightX, currentY);
                            currentY += padding * 0.8;
                            
                            ctx.strokeStyle = canvasBgColor === '#ffffff' ? '#d0d7de' : '#30363d';
                            ctx.beginPath();
                            ctx.moveTo(rightX, currentY);
                            ctx.lineTo(rightX + rightPanel - padding * 2, currentY);
                            ctx.stroke();
                            currentY += padding * 0.8;
                            
                            ctx.font = `${resolution * 0.013}px Arial`;
                            ctx.fillStyle = textColor;
                            
                            ctx.fillText(`œÜ(M) = ${currentData.phi}`, rightX, currentY);
                            currentY += padding * 0.6;
                            ctx.fillText(`Reducible Residues: ${M - currentData.phi}`, rightX, currentY);
                            currentY += padding * 0.6;
                            const reduciblePercent = ((M - currentData.phi) / M * 100).toFixed(1);
                            ctx.fillText(`Reducibility Ratio: ${reduciblePercent}%`, rightX, currentY);
                            currentY += padding * 0.6;
                            
                            const divisors = [];
                            for (let d = 1; d < M; d++) {
                                if (M % d === 0) divisors.push(d);
                            }
                            ctx.fillText(`Farey Channels: ${divisors.length}`, rightX, currentY);
                            currentY += padding * 1.2;
                            
                            // COLOR KEY section
                            ctx.font = `bold ${resolution * 0.018}px Arial`;
                            ctx.fillStyle = headingColor;
                            ctx.fillText('COLOR KEY', rightX, currentY);
                            currentY += padding * 0.8;
                            
                            ctx.strokeStyle = canvasBgColor === '#ffffff' ? '#d0d7de' : '#30363d';
                            ctx.beginPath();
                            ctx.moveTo(rightX, currentY);
                            ctx.lineTo(rightX + rightPanel - padding * 2, currentY);
                            ctx.stroke();
                            currentY += padding * 0.8;
                            
                            const swatchSize = resolution * 0.015;
                            const swatchGap = resolution * 0.025;
                            
                            ctx.font = `${resolution * 0.012}px Arial`;
                            ctx.fillStyle = textColor;
                            
                            ctx.fillStyle = '#00ffff';
                            ctx.fillRect(rightX, currentY - swatchSize * 0.7, swatchSize, swatchSize);
                            ctx.fillStyle = textColor;
                            ctx.fillText('Cyan = Irreducible (gcd=1)', rightX + swatchGap, currentY);
                            currentY += padding * 0.8;
                            
                            ctx.fillStyle = '#ff1493';
                            ctx.fillRect(rightX, currentY - swatchSize * 0.7, swatchSize, swatchSize);
                            ctx.fillStyle = textColor;
                            ctx.fillText('Red = Reducible (gcd>1)', rightX + swatchGap, currentY);
                            currentY += padding * 0.8;
                            
                            ctx.fillStyle = '#ff0000';
                            ctx.fillRect(rightX, currentY - swatchSize * 0.7, swatchSize, swatchSize);
                            ctx.fillStyle = textColor;
                            ctx.fillText('Red Lines = Farey Channels', rightX + swatchGap, currentY);
                            currentY += padding * 0.8;
                            
                            ctx.fillStyle = '#ffd700';
                            ctx.fillRect(rightX, currentY - swatchSize * 0.7, swatchSize, swatchSize);
                            ctx.fillStyle = textColor;
                            ctx.fillText('Gold = Channel Rings', rightX + swatchGap, currentY);
                            currentY += padding * 1.2;
                            
                            ctx.font = `${resolution * 0.011}px Arial`;
                            ctx.fillStyle = mutedColor;
                            const maxWidth = rightPanel - padding * 3;
                            wrapText(ctx, 'Farey Lines: Connect each reducible residue r/M on the outer ring to its reduced form r\'/M\' on the corresponding inner channel ring.', 
                                    rightX, currentY, maxWidth, padding * 0.5);
                            currentY += padding * 2.5;
                            
                            // KEY RESULT section
                            ctx.font = `bold ${resolution * 0.018}px Arial`;
                            ctx.fillStyle = headingColor;
                            ctx.fillText('KEY RESULT', rightX, currentY);
                            currentY += padding * 0.8;
                            
                            ctx.strokeStyle = canvasBgColor === '#ffffff' ? '#d0d7de' : '#30363d';
                            ctx.beginPath();
                            ctx.moveTo(rightX, currentY);
                            ctx.lineTo(rightX + rightPanel - padding * 2, currentY);
                            ctx.stroke();
                            currentY += padding * 0.8;
                            
                            ctx.font = `${resolution * 0.011}px Arial`;
                            ctx.fillStyle = textColor;
                            wrapText(ctx, 'Every composite M has reducible residues projecting onto simpler Farey channels. The number projecting to channel M\' is exactly d = M/M\' (multiplicity).', 
                                    rightX, currentY, maxWidth, padding * 0.5);
                            currentY += padding * 2.5;
                        }
                        
                        // METADATA section at bottom
                        currentY = canvas.height - padding * 4;
                        ctx.font = `bold ${resolution * 0.016}px Arial`;
                        ctx.fillStyle = headingColor;
                        ctx.fillText('METADATA', rightX, currentY);
                        currentY += padding * 0.8;
                        
                        ctx.font = `${resolution * 0.01}px Arial`;
                        ctx.fillStyle = mutedColor;
                        ctx.fillText(`Generated: ${new Date().toLocaleString()}`, rightX, currentY);
                        currentY += padding * 0.5;
                        ctx.fillText('Author: Wessen Getachew', rightX, currentY);
                        currentY += padding * 0.5;
                        ctx.fillText('Tool: Modular Reduction Projection Explorer', rightX, currentY);
                        currentY += padding * 0.5;
                        ctx.fillText(`Resolution: ${resolution}√ó${resolution}`, rightX, currentY);
                    }
                }
                
                URL.revokeObjectURL(url);
                
                // Save canvas as PNG
                canvas.toBlob(blob => {
                    const a = document.createElement('a');
                    a.href = URL.createObjectURL(blob);
                    const filename = multiModEnabled ? 
                        `multimod-${document.getElementById('multiModStart').value}-to-${document.getElementById('multiModEnd').value}-${Date.now()}.png` :
                        `modular-M${M}-${Date.now()}.png`;
                    a.download = filename;
                    a.click();
                });
            };
            
            img.src = url;
        }
        
        // Helper function to wrap text
        function wrapText(ctx, text, x, y, maxWidth, lineHeight) {
            const words = text.split(' ');
            let line = '';
            let currentY = y;
            
            for (let n = 0; n < words.length; n++) {
                const testLine = line + words[n] + ' ';
                const metrics = ctx.measureText(testLine);
                const testWidth = metrics.width;
                
                if (testWidth > maxWidth && n > 0) {
                    ctx.fillText(line, x, currentY);
                    line = words[n] + ' ';
                    currentY += lineHeight;
                } else {
                    line = testLine;
                }
            }
            ctx.fillText(line, x, currentY);
        }

        function exportCSV() {
            let csv = 'r,M,gcd,coprime,angle_rad,angle_deg,channel,x,y\n';
            currentData.residues.forEach(res => {
                const angleDeg = ((res.angle + Math.PI/2) * 180 / Math.PI) % 360;
                csv += `${res.r},${M},${res.gcd},${res.coprime},${res.angle.toFixed(6)},${angleDeg.toFixed(2)},${res.channel},${res.x.toFixed(2)},${res.y.toFixed(2)}\n`;
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `modular-M${M}-${Date.now()}.csv`;
            a.click();
        }

        function exportJSON() {
            const data = {
                metadata: { M, timestamp: new Date().toISOString(), version: '2.0' },
                statistics: {
                    phi: currentData.phi,
                    coprime_count: currentData.residues.filter(r => r.coprime).length,
                    density: currentData.phi / M,
                    is_prime: currentData.isPrime,
                    omega: currentData.omega
                },
                residues: currentData.residues
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = `modular-M${M}-${Date.now()}.json`;
            a.click();
        }

        // Event listeners
        document.getElementById('modulusSlider').addEventListener('input', (e) => {
            setModulus(parseInt(e.target.value));
        });

        document.getElementById('modulusInput').addEventListener('change', (e) => {
            const value = Math.max(2, Math.min(10000, parseInt(e.target.value) || 2));
            setModulus(value);
        });

        document.getElementById('animSpeed').addEventListener('input', (e) => {
            document.getElementById('speedValue').textContent = e.target.value;
        });

        document.getElementById('speedMultiplier').addEventListener('input', (e) => {
            document.getElementById('speedMultValue').textContent = parseFloat(e.target.value).toFixed(1);
        });

        document.getElementById('zoom').addEventListener('input', (e) => {
            document.getElementById('zoomValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('rotation').addEventListener('input', (e) => {
            document.getElementById('rotationValue').textContent = e.target.value;
        });

        document.getElementById('ringRotation').addEventListener('input', (e) => {
            const value = parseFloat(e.target.value);
            document.getElementById('ringRotValue').textContent = value.toFixed(1);
            document.getElementById('ringRotInput').value = Math.round(value);
        });

        document.getElementById('ringRotInput').addEventListener('change', (e) => {
            const value = Math.max(0, Math.min(3600, parseFloat(e.target.value) || 0));
            document.getElementById('ringRotation').value = value;
            document.getElementById('ringRotValue').textContent = value.toFixed(1);
            render();
        });

        document.getElementById('canvasBg').addEventListener('change', render);
        document.getElementById('customBgColor').addEventListener('change', render);
        document.getElementById('ringColorMode').addEventListener('change', render);
        document.getElementById('customRingColor').addEventListener('change', render);

        document.getElementById('connThickness').addEventListener('input', (e) => {
            document.getElementById('connThickValue').textContent = parseFloat(e.target.value).toFixed(1);
        });

        document.getElementById('gapSize').addEventListener('input', (e) => {
            document.getElementById('gapSizeValue').textContent = e.target.value;
        });

        document.getElementById('connOpacity').addEventListener('input', (e) => {
            document.getElementById('connOpacityValue').textContent = e.target.value;
        });

        document.getElementById('ringSpacing').addEventListener('input', (e) => {
            document.getElementById('ringSpacingValue').textContent = parseFloat(e.target.value).toFixed(1);
        });

        document.getElementById('fareyThickness').addEventListener('input', (e) => {
            document.getElementById('fareyThickValue').textContent = parseFloat(e.target.value).toFixed(1);
        });

        document.getElementById('lineThick').addEventListener('input', (e) => {
            document.getElementById('lineThickValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        document.getElementById('pointSize').addEventListener('input', (e) => {
            document.getElementById('pointSizeValue').textContent = parseFloat(e.target.value).toFixed(1);
        });

        document.getElementById('opacity').addEventListener('input', (e) => {
            document.getElementById('opacityValue').textContent = e.target.value;
        });

        document.getElementById('labelSize').addEventListener('input', (e) => {
            document.getElementById('labelSizeValue').textContent = e.target.value;
        });

        document.getElementById('labelDist').addEventListener('input', (e) => {
            document.getElementById('labelDistValue').textContent = parseFloat(e.target.value).toFixed(2);
        });

        // Initialize
        setModulus(32);
    </script>
</body>
</html>
